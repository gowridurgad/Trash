/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the  "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace org.apache.xml.serializer.utils
{

	/// <summary>
	/// THIS IS A COPY OF THE XERCES-2J CLASS org.apache.xerces.utls.XMLChar
	/// 
	/// This class defines the basic properties of characters in XML 1.1. The data
	/// in this class can be used to verify that a character is a valid
	/// XML 1.1 character or if the character is a space, name start, or name
	/// character.
	/// <para>
	/// A series of convenience methods are supplied to ease the burden
	/// of the developer.  Using the character as an index into the <code>XML11CHARS</code>
	/// array and applying the appropriate mask flag (e.g.
	/// <code>MASK_VALID</code>), yields the same results as calling the
	/// convenience methods. There is one exception: check the comments
	/// for the <code>isValid</code> method for details.
	/// 
	/// @author Glenn Marcy, IBM
	/// @author Andy Clark, IBM
	/// @author Arnaud  Le Hors, IBM
	/// @author Neil Graham, IBM
	/// @author Michael Glavassevich, IBM
	/// 
	/// @version $Id: XML11Char.java 1225426 2011-12-29 04:13:08Z mrglavas $
	/// </para>
	/// </summary>
	public class XML11Char
	{

		//
		// Constants
		//

		/// <summary>
		/// Character flags for XML 1.1. </summary>
		private static readonly sbyte[] XML11CHARS = new sbyte [1 << 16];

		/// <summary>
		/// XML 1.1 Valid character mask. </summary>
		public const int MASK_XML11_VALID = 0x01;

		/// <summary>
		/// XML 1.1 Space character mask. </summary>
		public const int MASK_XML11_SPACE = 0x02;

		/// <summary>
		/// XML 1.1 Name start character mask. </summary>
		public const int MASK_XML11_NAME_START = 0x04;

		/// <summary>
		/// XML 1.1 Name character mask. </summary>
		public const int MASK_XML11_NAME = 0x08;

		/// <summary>
		/// XML 1.1 control character mask </summary>
		public const int MASK_XML11_CONTROL = 0x10;

		/// <summary>
		/// XML 1.1 content for external entities (valid - "special" chars - control chars) </summary>
		public const int MASK_XML11_CONTENT = 0x20;

		/// <summary>
		/// XML namespaces 1.1 NCNameStart </summary>
		public const int MASK_XML11_NCNAME_START = 0x40;

		/// <summary>
		/// XML namespaces 1.1 NCName </summary>
		public const int MASK_XML11_NCNAME = 0x80;

		/// <summary>
		/// XML 1.1 content for internal entities (valid - "special" chars) </summary>
		public static readonly int MASK_XML11_CONTENT_INTERNAL = MASK_XML11_CONTROL | MASK_XML11_CONTENT;

		//
		// Static initialization
		//

		static XML11Char()
		{

			// Initializing the Character Flag Array
			// Code generated by: XML11CharGenerator.

			Arrays.fill(XML11CHARS, 1, 9, (sbyte) 17); // Fill 8 of value (byte) 17
			XML11CHARS[9] = 35;
			XML11CHARS[10] = 3;
			Arrays.fill(XML11CHARS, 11, 13, (sbyte) 17); // Fill 2 of value (byte) 17
			XML11CHARS[13] = 3;
			Arrays.fill(XML11CHARS, 14, 32, (sbyte) 17); // Fill 18 of value (byte) 17
			XML11CHARS[32] = 35;
			Arrays.fill(XML11CHARS, 33, 38, (sbyte) 33); // Fill 5 of value (byte) 33
			XML11CHARS[38] = 1;
			Arrays.fill(XML11CHARS, 39, 45, (sbyte) 33); // Fill 6 of value (byte) 33
			Arrays.fill(XML11CHARS, 45, 47, (sbyte) -87); // Fill 2 of value (byte) -87
			XML11CHARS[47] = 33;
			Arrays.fill(XML11CHARS, 48, 58, (sbyte) -87); // Fill 10 of value (byte) -87
			XML11CHARS[58] = 45;
			XML11CHARS[59] = 33;
			XML11CHARS[60] = 1;
			Arrays.fill(XML11CHARS, 61, 65, (sbyte) 33); // Fill 4 of value (byte) 33
			Arrays.fill(XML11CHARS, 65, 91, (sbyte) -19); // Fill 26 of value (byte) -19
			Arrays.fill(XML11CHARS, 91, 93, (sbyte) 33); // Fill 2 of value (byte) 33
			XML11CHARS[93] = 1;
			XML11CHARS[94] = 33;
			XML11CHARS[95] = -19;
			XML11CHARS[96] = 33;
			Arrays.fill(XML11CHARS, 97, 123, (sbyte) -19); // Fill 26 of value (byte) -19
			Arrays.fill(XML11CHARS, 123, 127, (sbyte) 33); // Fill 4 of value (byte) 33
			Arrays.fill(XML11CHARS, 127, 133, (sbyte) 17); // Fill 6 of value (byte) 17
			XML11CHARS[133] = 35;
			Arrays.fill(XML11CHARS, 134, 160, (sbyte) 17); // Fill 26 of value (byte) 17
			Arrays.fill(XML11CHARS, 160, 183, (sbyte) 33); // Fill 23 of value (byte) 33
			XML11CHARS[183] = -87;
			Arrays.fill(XML11CHARS, 184, 192, (sbyte) 33); // Fill 8 of value (byte) 33
			Arrays.fill(XML11CHARS, 192, 215, (sbyte) -19); // Fill 23 of value (byte) -19
			XML11CHARS[215] = 33;
			Arrays.fill(XML11CHARS, 216, 247, (sbyte) -19); // Fill 31 of value (byte) -19
			XML11CHARS[247] = 33;
			Arrays.fill(XML11CHARS, 248, 768, (sbyte) -19); // Fill 520 of value (byte) -19
			Arrays.fill(XML11CHARS, 768, 880, (sbyte) -87); // Fill 112 of value (byte) -87
			Arrays.fill(XML11CHARS, 880, 894, (sbyte) -19); // Fill 14 of value (byte) -19
			XML11CHARS[894] = 33;
			Arrays.fill(XML11CHARS, 895, 8192, (sbyte) -19); // Fill 7297 of value (byte) -19
			Arrays.fill(XML11CHARS, 8192, 8204, (sbyte) 33); // Fill 12 of value (byte) 33
			Arrays.fill(XML11CHARS, 8204, 8206, (sbyte) -19); // Fill 2 of value (byte) -19
			Arrays.fill(XML11CHARS, 8206, 8232, (sbyte) 33); // Fill 26 of value (byte) 33
			XML11CHARS[8232] = 35;
			Arrays.fill(XML11CHARS, 8233, 8255, (sbyte) 33); // Fill 22 of value (byte) 33
			Arrays.fill(XML11CHARS, 8255, 8257, (sbyte) -87); // Fill 2 of value (byte) -87
			Arrays.fill(XML11CHARS, 8257, 8304, (sbyte) 33); // Fill 47 of value (byte) 33
			Arrays.fill(XML11CHARS, 8304, 8592, (sbyte) -19); // Fill 288 of value (byte) -19
			Arrays.fill(XML11CHARS, 8592, 11264, (sbyte) 33); // Fill 2672 of value (byte) 33
			Arrays.fill(XML11CHARS, 11264, 12272, (sbyte) -19); // Fill 1008 of value (byte) -19
			Arrays.fill(XML11CHARS, 12272, 12289, (sbyte) 33); // Fill 17 of value (byte) 33
			Arrays.fill(XML11CHARS, 12289, 55296, (sbyte) -19); // Fill 43007 of value (byte) -19
			Arrays.fill(XML11CHARS, 57344, 63744, (sbyte) 33); // Fill 6400 of value (byte) 33
			Arrays.fill(XML11CHARS, 63744, 64976, (sbyte) -19); // Fill 1232 of value (byte) -19
			Arrays.fill(XML11CHARS, 64976, 65008, (sbyte) 33); // Fill 32 of value (byte) 33
			Arrays.fill(XML11CHARS, 65008, 65534, (sbyte) -19); // Fill 526 of value (byte) -19

		} // <clinit>()

		//
		// Public static methods
		//

		/// <summary>
		/// Returns true if the specified character is a space character
		/// as amdended in the XML 1.1 specification.
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11Space(int c)
		{
			return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_SPACE) != 0);
		} // isXML11Space(int):boolean

		/// <summary>
		/// Returns true if the specified character is valid. This method
		/// also checks the surrogate character range from 0x10000 to 0x10FFFF.
		/// <para>
		/// If the program chooses to apply the mask directly to the
		/// <code>XML11CHARS</code> array, then they are responsible for checking
		/// the surrogate character range.
		/// 
		/// </para>
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11Valid(int c)
		{
			return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_VALID) != 0) || (0x10000 <= c && c <= 0x10FFFF);
		} // isXML11Valid(int):boolean

		/// <summary>
		/// Returns true if the specified character is invalid.
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11Invalid(int c)
		{
			return !isXML11Valid(c);
		} // isXML11Invalid(int):boolean

		/// <summary>
		/// Returns true if the specified character is valid and permitted outside
		/// of a character reference.  
		/// That is, this method will return false for the same set as
		/// isXML11Valid, except it also reports false for "control characters".
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11ValidLiteral(int c)
		{
			return ((c < 0x10000 && ((XML11CHARS[c] & MASK_XML11_VALID) != 0 && (XML11CHARS[c] & MASK_XML11_CONTROL) == 0)) || (0x10000 <= c && c <= 0x10FFFF));
		} // isXML11ValidLiteral(int):boolean

		/// <summary>
		/// Returns true if the specified character can be considered 
		/// content in an external parsed entity.
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11Content(int c)
		{
			return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_CONTENT) != 0) || (0x10000 <= c && c <= 0x10FFFF);
		} // isXML11Content(int):boolean

		/// <summary>
		/// Returns true if the specified character can be considered 
		/// content in an internal parsed entity.
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11InternalEntityContent(int c)
		{
			return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_CONTENT_INTERNAL) != 0) || (0x10000 <= c && c <= 0x10FFFF);
		} // isXML11InternalEntityContent(int):boolean

		/// <summary>
		/// Returns true if the specified character is a valid name start
		/// character as defined by production [4] in the XML 1.1
		/// specification.
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11NameStart(int c)
		{
			return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_NAME_START) != 0) || (0x10000 <= c && c < 0xF0000);
		} // isXML11NameStart(int):boolean

		/// <summary>
		/// Returns true if the specified character is a valid name
		/// character as defined by production [4a] in the XML 1.1
		/// specification.
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11Name(int c)
		{
			return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_NAME) != 0) || (c >= 0x10000 && c < 0xF0000);
		} // isXML11Name(int):boolean

		/// <summary>
		/// Returns true if the specified character is a valid NCName start
		/// character as defined by production [4] in Namespaces in XML
		/// 1.1 recommendation.
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11NCNameStart(int c)
		{
			return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_NCNAME_START) != 0) || (0x10000 <= c && c < 0xF0000);
		} // isXML11NCNameStart(int):boolean

		/// <summary>
		/// Returns true if the specified character is a valid NCName
		/// character as defined by production [5] in Namespaces in XML
		/// 1.1 recommendation.
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11NCName(int c)
		{
			return (c < 0x10000 && (XML11CHARS[c] & MASK_XML11_NCNAME) != 0) || (0x10000 <= c && c < 0xF0000);
		} // isXML11NCName(int):boolean

		/// <summary>
		/// Returns whether the given character is a valid 
		/// high surrogate for a name character. This includes
		/// all high surrogates for characters [0x10000-0xEFFFF].
		/// In other words everything excluding planes 15 and 16.
		/// </summary>
		/// <param name="c"> The character to check. </param>
		public static bool isXML11NameHighSurrogate(int c)
		{
			return (0xD800 <= c && c <= 0xDB7F);
		}

		/*
		 * [5] Name ::= NameStartChar NameChar*
		 */
		/// <summary>
		/// Check to see if a string is a valid Name according to [5]
		/// in the XML 1.1 Recommendation
		/// </summary>
		/// <param name="name"> string to check </param>
		/// <returns> true if name is a valid Name </returns>
		public static bool isXML11ValidName(string name)
		{
			int length = name.Length;
			if (length == 0)
			{
				return false;
			}
			int i = 1;
			char ch = name[0];
			if (!isXML11NameStart(ch))
			{
				if (length > 1 && isXML11NameHighSurrogate(ch))
				{
					char ch2 = name[1];
					if (!XMLChar.isLowSurrogate(ch2) || !isXML11NameStart(XMLChar.supplemental(ch, ch2)))
					{
						return false;
					}
					i = 2;
				}
				else
				{
					return false;
				}
			}
			while (i < length)
			{
				ch = name[i];
				if (!isXML11Name(ch))
				{
					if (++i < length && isXML11NameHighSurrogate(ch))
					{
						char ch2 = name[i];
						if (!XMLChar.isLowSurrogate(ch2) || !isXML11Name(XMLChar.supplemental(ch, ch2)))
						{
							return false;
						}
					}
					else
					{
						return false;
					}
				}
				++i;
			}
			return true;
		} // isXML11ValidName(String):boolean


		/*
		 * from the namespace 1.1 rec
		 * [4] NCName ::= NCNameStartChar NCNameChar*
		 */
		/// <summary>
		/// Check to see if a string is a valid NCName according to [4]
		/// from the XML Namespaces 1.1 Recommendation
		/// </summary>
		/// <param name="ncName"> string to check </param>
		/// <returns> true if name is a valid NCName </returns>
		public static bool isXML11ValidNCName(string ncName)
		{
			int length = ncName.Length;
			if (length == 0)
			{
				return false;
			}
			int i = 1;
			char ch = ncName[0];
			if (!isXML11NCNameStart(ch))
			{
				if (length > 1 && isXML11NameHighSurrogate(ch))
				{
					char ch2 = ncName[1];
					if (!XMLChar.isLowSurrogate(ch2) || !isXML11NCNameStart(XMLChar.supplemental(ch, ch2)))
					{
						return false;
					}
					i = 2;
				}
				else
				{
					return false;
				}
			}
			while (i < length)
			{
				ch = ncName[i];
				if (!isXML11NCName(ch))
				{
					if (++i < length && isXML11NameHighSurrogate(ch))
					{
						char ch2 = ncName[i];
						if (!XMLChar.isLowSurrogate(ch2) || !isXML11NCName(XMLChar.supplemental(ch, ch2)))
						{
							return false;
						}
					}
					else
					{
						return false;
					}
				}
				++i;
			}
			return true;
		} // isXML11ValidNCName(String):boolean

		/*
		 * [7] Nmtoken ::= (NameChar)+
		 */
		/// <summary>
		/// Check to see if a string is a valid Nmtoken according to [7]
		/// in the XML 1.1 Recommendation
		/// </summary>
		/// <param name="nmtoken"> string to check </param>
		/// <returns> true if nmtoken is a valid Nmtoken  </returns>
		public static bool isXML11ValidNmtoken(string nmtoken)
		{
			int length = nmtoken.Length;
			if (length == 0)
			{
				return false;
			}
			for (int i = 0; i < length; ++i)
			{
				char ch = nmtoken[i];
				if (!isXML11Name(ch))
				{
					if (++i < length && isXML11NameHighSurrogate(ch))
					{
						char ch2 = nmtoken[i];
						if (!XMLChar.isLowSurrogate(ch2) || !isXML11Name(XMLChar.supplemental(ch, ch2)))
						{
							return false;
						}
					}
					else
					{
						return false;
					}
				}
			}
			return true;
		} // isXML11ValidName(String):boolean

	} // class XML11Char


}