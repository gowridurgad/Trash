using System.Collections;
using System.Text;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the  "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * $Id: AttributeSet.java 468650 2006-10-28 07:03:30Z minchau $
 */

namespace org.apache.xalan.xsltc.compiler
{


	using ConstantPoolGen = org.apache.bcel.generic.ConstantPoolGen;
	using INVOKESPECIAL = org.apache.bcel.generic.INVOKESPECIAL;
	using InstructionList = org.apache.bcel.generic.InstructionList;
	using AttributeSetMethodGenerator = org.apache.xalan.xsltc.compiler.util.AttributeSetMethodGenerator;
	using ClassGenerator = org.apache.xalan.xsltc.compiler.util.ClassGenerator;
	using ErrorMsg = org.apache.xalan.xsltc.compiler.util.ErrorMsg;
	using MethodGenerator = org.apache.xalan.xsltc.compiler.util.MethodGenerator;
	using Type = org.apache.xalan.xsltc.compiler.util.Type;
	using TypeCheckError = org.apache.xalan.xsltc.compiler.util.TypeCheckError;
	using Util = org.apache.xalan.xsltc.compiler.util.Util;
	using XML11Char = org.apache.xml.utils.XML11Char;

	/// <summary>
	/// @author Jacek Ambroziak
	/// @author Santiago Pericas-Geertsen
	/// @author Morten Jorgensen
	/// </summary>
	internal sealed class AttributeSet : TopLevelElement
	{

		// This prefix is used for the method name of attribute set methods
		private const string AttributeSetPrefix = "$as$";

		// Element contents
		private QName _name;
		private UseAttributeSets _useSets;
		private AttributeSet _mergeSet;
		private string _method;
		private bool _ignore = false;

		/// <summary>
		/// Returns the QName of this attribute set
		/// </summary>
		public QName Name
		{
			get
			{
			return _name;
			}
		}

		/// <summary>
		/// Returns the method name of this attribute set. This method name is
		/// generated by the compiler (XSLTC)
		/// </summary>
		public string MethodName
		{
			get
			{
			return _method;
			}
		}

		/// <summary>
		/// Call this method to prevent a method for being compiled for this set.
		/// This is used in case several <xsl:attribute-set...> elements constitute
		/// a single set (with one name). The last element will merge itself with
		/// any previous set(s) with the same name and disable the other set(s).
		/// </summary>
		public void ignore()
		{
		_ignore = true;
		}

		/// <summary>
		/// Parse the contents of this attribute set. Recognised attributes are
		/// "name" (required) and "use-attribute-sets" (optional).
		/// </summary>
		public override void parseContents(Parser parser)
		{

		// Get this attribute set's name
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String name = getAttribute("name");
			string name = getAttribute("name");

			if (!XML11Char.isXML11ValidQName(name))
			{
				ErrorMsg err = new ErrorMsg(ErrorMsg.INVALID_QNAME_ERR, name, this);
				parser.reportError(Constants_Fields.ERROR, err);
			}
			_name = parser.getQNameIgnoreDefaultNs(name);
		if ((_name == null) || (_name.Equals(Constants_Fields.EMPTYSTRING)))
		{
			ErrorMsg msg = new ErrorMsg(ErrorMsg.UNNAMED_ATTRIBSET_ERR, this);
			parser.reportError(Constants_Fields.ERROR, msg);
		}

		// Get any included attribute sets (similar to inheritance...)
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String useSets = getAttribute("use-attribute-sets");
		string useSets = getAttribute("use-attribute-sets");
		if (useSets.Length > 0)
		{
				if (!Util.isValidQNames(useSets))
				{
					ErrorMsg err = new ErrorMsg(ErrorMsg.INVALID_QNAME_ERR, useSets, this);
					parser.reportError(Constants_Fields.ERROR, err);
				}
			_useSets = new UseAttributeSets(useSets, parser);
		}

		// Parse the contents of this node. All child elements must be
		// <xsl:attribute> elements. Other elements cause an error.
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final java.util.Vector contents = getContents();
		ArrayList contents = Contents;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final int count = contents.size();
		int count = contents.Count;
		for (int i = 0; i < count; i++)
		{
			SyntaxTreeNode child = (SyntaxTreeNode)contents[i];
			if (child is XslAttribute)
			{
			parser.SymbolTable.CurrentNode = child;
			child.parseContents(parser);
			}
			else if (child is Text)
			{
			// ignore
			}
			else
			{
			ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_CHILD_ERR, this);
			parser.reportError(Constants_Fields.ERROR, msg);
			}
		}

		// Point the symbol table back at us...
		parser.SymbolTable.CurrentNode = this;
		}

		/// <summary>
		/// Type check the contents of this element
		/// </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in .NET:
//ORIGINAL LINE: public org.apache.xalan.xsltc.compiler.util.Type typeCheck(SymbolTable stable) throws org.apache.xalan.xsltc.compiler.util.TypeCheckError
		public override Type typeCheck(SymbolTable stable)
		{

		if (_ignore)
		{
			return (Type.Void);
		}

			// _mergeSet Point to any previous definition of this attribute set
		_mergeSet = stable.addAttributeSet(this);

		_method = AttributeSetPrefix + XSLTC.nextAttributeSetSerial();

		if (_useSets != null)
		{
			_useSets.typeCheck(stable);
		}
		typeCheckContents(stable);
		return Type.Void;
		}

		/// <summary>
		/// Compile a method that outputs the attributes in this set
		/// </summary>
		public override void translate(ClassGenerator classGen, MethodGenerator methodGen)
		{

		if (_ignore)
		{
			return;
		}

		// Create a new method generator for an attribute set method
		methodGen = new AttributeSetMethodGenerator(_method, classGen);

			// Generate a reference to previous attribute-set definitions with the
			// same name first.  Those later in the stylesheet take precedence.
			if (_mergeSet != null)
			{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final org.apache.bcel.generic.ConstantPoolGen cpg = classGen.getConstantPool();
				ConstantPoolGen cpg = classGen.ConstantPool;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final org.apache.bcel.generic.InstructionList il = methodGen.getInstructionList();
				InstructionList il = methodGen.InstructionList;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String methodName = _mergeSet.getMethodName();
				string methodName = _mergeSet.MethodName;

				il.append(classGen.loadTranslet());
				il.append(methodGen.loadDOM());
				il.append(methodGen.loadIterator());
				il.append(methodGen.loadHandler());
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final int method = cpg.addMethodref(classGen.getClassName(), methodName, Constants_Fields.ATTR_SET_SIG);
				int method = cpg.addMethodref(classGen.ClassName, methodName, Constants_Fields.ATTR_SET_SIG);
				il.append(new INVOKESPECIAL(method));
			}

		// Translate other used attribute sets first, as local attributes
		// take precedence (last attributes overrides first)
		if (_useSets != null)
		{
			_useSets.translate(classGen, methodGen);
		}

		// Translate all local attributes
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final java.util.Enumeration attributes = elements();
		System.Collections.IEnumerator attributes = elements();
		while (attributes.MoveNext())
		{
			SyntaxTreeNode element = (SyntaxTreeNode)attributes.Current;
			if (element is XslAttribute)
			{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final XslAttribute attribute = (XslAttribute)element;
			XslAttribute attribute = (XslAttribute)element;
			attribute.translate(classGen, methodGen);
			}
		}
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final org.apache.bcel.generic.InstructionList il = methodGen.getInstructionList();
		InstructionList il = methodGen.InstructionList;
		il.append(RETURN);

		classGen.addMethod(methodGen);
		}

		public override string ToString()
		{
		StringBuilder buf = new StringBuilder("attribute-set: ");
		// Translate all local attributes
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final java.util.Enumeration attributes = elements();
		System.Collections.IEnumerator attributes = elements();
		while (attributes.MoveNext())
		{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final XslAttribute attribute = (XslAttribute)attributes.Current;
			XslAttribute attribute = (XslAttribute)attributes.Current;
			buf.Append(attribute);
		}
		return (buf.ToString());
		}
	}

}