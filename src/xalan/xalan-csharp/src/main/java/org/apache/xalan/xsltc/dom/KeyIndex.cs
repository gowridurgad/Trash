/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the  "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * $Id: KeyIndex.java 468651 2006-10-28 07:04:25Z minchau $
 */

namespace org.apache.xalan.xsltc.dom
{

	using DOM = org.apache.xalan.xsltc.DOM;
	using DOMEnhancedForDTM = org.apache.xalan.xsltc.DOMEnhancedForDTM;
	using BasisLibrary = org.apache.xalan.xsltc.runtime.BasisLibrary;
	using Hashtable = org.apache.xalan.xsltc.runtime.Hashtable;
	using IntegerArray = org.apache.xalan.xsltc.util.IntegerArray;

	using Axis = org.apache.xml.dtm.Axis;
	using DTM = org.apache.xml.dtm.DTM;
	using DTMAxisIterator = org.apache.xml.dtm.DTMAxisIterator;
	using DTMAxisIteratorBase = org.apache.xml.dtm.@ref.DTMAxisIteratorBase;

	/// <summary>
	/// Stores mappings of key values or IDs to DTM nodes.
	/// <em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
	/// <b>deprecated.</b></em>
	/// @author Morten Jorgensen
	/// @author Santiago Pericas-Geertsen
	/// </summary>
	public class KeyIndex : DTMAxisIteratorBase
	{

		/// <summary>
		/// A mapping between values and nodesets for the current document.  Used
		/// only while building keys.
		/// </summary>
		private Hashtable _index;

		/// <summary>
		/// The document node currently being processed.  Used only while building
		/// keys.
		/// </summary>
		private int _currentDocumentNode = DTM.NULL;

		/// <summary>
		/// A mapping from a document node to the mapping between values and nodesets
		/// </summary>
		private Hashtable _rootToIndexMap = new Hashtable();

		/// <summary>
		/// The node set associated to the current value passed
		/// to lookupKey();
		/// </summary>
		private IntegerArray _nodes = null;

		/// <summary>
		/// The XSLTC DOM object if this KeyIndex is being used to implement the
		/// id() function.
		/// </summary>
		private DOM _dom;

		private DOMEnhancedForDTM _enhancedDOM;

		/// <summary>
		/// Store position after call to setMark()
		/// </summary>
		private int _markedPosition = 0;

		public KeyIndex(int dummy)
		{
		}

		public override bool Restartable
		{
			set
			{
			}
		}

		/// <summary>
		/// Adds a node to the node list for a given value. Nodes will
		/// always be added in document order.
		/// </summary>
		public virtual void add(object value, int node, int rootNode)
		{
			if (_currentDocumentNode != rootNode)
			{
				_currentDocumentNode = rootNode;
				_index = new Hashtable();
				_rootToIndexMap.put(new int?(rootNode), _index);
			}

			IntegerArray nodes = (IntegerArray) _index.get(value);

			if (nodes == null)
			{
				 nodes = new IntegerArray();
				_index.put(value, nodes);
				nodes.add(node);

			// Because nodes are added in document order,
			// duplicates can be eliminated easily at this stage.
			}
			else if (node != nodes.at(nodes.cardinality() - 1))
			{
				nodes.add(node);
			}
		}

		/// <summary>
		/// Merge the current value's nodeset set by lookupKey() with _nodes.
		/// @deprecated
		/// </summary>
		public virtual void merge(KeyIndex other)
		{
		if (other == null)
		{
			return;
		}

		if (other._nodes != null)
		{
			if (_nodes == null)
			{
			_nodes = (IntegerArray)other._nodes.clone();
			}
			else
			{
			_nodes.merge(other._nodes);
			}
		}
		}

		/// <summary>
		/// This method must be called by the code generated by the id() function
		/// prior to returning the node iterator. The lookup code for key() and
		/// id() differ in the way the lookup value can be whitespace separated
		/// list of tokens for the id() function, but a single string for the
		/// key() function.
		/// @deprecated
		/// </summary>
		public virtual void lookupId(object value)
		{
		// Clear _nodes array
		_nodes = null;

//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final java.util.StringTokenizer values = new java.util.StringTokenizer((String) value, " \n\t");
		StringTokenizer values = new StringTokenizer((string) value, " \n\t");
		while (values.hasMoreElements())
		{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String token = (String) values.nextElement();
				string token = (string) values.nextElement();
			IntegerArray nodes = (IntegerArray) _index.get(token);

				if (nodes == null && _enhancedDOM != null && _enhancedDOM.hasDOMSource())
				{
					nodes = getDOMNodeById(token);
				}

			if (nodes == null)
			{
				continue;
			}

			if (_nodes == null)
			{
			 nodes = (IntegerArray)nodes.clone();
			_nodes = nodes;
			}
			else
			{
			_nodes.merge(nodes);
			}
		}
		}

		/// <summary>
		/// Return an IntegerArray for the DOM Node which has the given id.
		/// </summary>
		/// <param name="id"> The id </param>
		/// <returns> A IntegerArray representing the Node whose id is the given value. </returns>
		public virtual IntegerArray getDOMNodeById(string id)
		{
			IntegerArray nodes = null;

			if (_enhancedDOM != null)
			{
				int ident = _enhancedDOM.getElementById(id);

				if (ident != DTM.NULL)
				{
					int? root = new int?(_enhancedDOM.Document);
					Hashtable index = (Hashtable) _rootToIndexMap.get(root.Value);

					if (index == null)
					{
						index = new Hashtable();
						_rootToIndexMap.put(root.Value, index);
					}
					else
					{
						nodes = (IntegerArray) index.get(id);
					}

					if (nodes == null)
					{
						nodes = new IntegerArray();
						index.put(id, nodes);
					}

					nodes.add(_enhancedDOM.getNodeHandle(ident));
				}
			}

			return nodes;
		}

		/// <summary>
		/// <para>This method must be called by the code generated by the key() function
		/// prior to returning the node iterator.</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public virtual void lookupKey(object value)
		{
			IntegerArray nodes = (IntegerArray) _index.get(value);
			_nodes = (nodes != null) ? (IntegerArray) nodes.clone() : null;
			_position = 0;
		}

		/// <summary>
		/// <para>Callers should not call next() after it returns END.</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override int next()
		{
		if (_nodes == null)
		{
			return DTMAxisIterator.END;
		}

		return (_position < _nodes.cardinality()) ? _dom.getNodeHandle(_nodes.at(_position++)) : DTMAxisIterator.END;
		}

		/// <summary>
		/// Given a context node and the argument to the XPath <code>id</code>
		/// function, checks whether the context node is in the set of nodes that
		/// results from that reference to the <code>id</code> function.  This is
		/// used in the implementation of <code>id</code> patterns.
		/// </summary>
		/// <param name="node"> The context node </param>
		/// <param name="value"> The argument to the <code>id</code> function </param>
		/// <returns> <code>1</code> if the context node is in the set of nodes
		///         returned by the reference to the <code>id</code> function;
		///         <code>0</code>, otherwise </returns>
		public virtual int containsID(int node, object value)
		{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String string = (String)value;
			string @string = (string)value;
			int rootHandle = _dom.getAxisIterator(Axis.ROOT).setStartNode(node).next();

			// Get the mapping table for the document containing the context node
			Hashtable index = (Hashtable) _rootToIndexMap.get(new int?(rootHandle));

			// Split argument to id function into XML whitespace separated tokens
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final java.util.StringTokenizer values = new java.util.StringTokenizer(string, " \n\t");
			StringTokenizer values = new StringTokenizer(@string, " \n\t");

			while (values.hasMoreElements())
			{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String token = (String) values.nextElement();
				string token = (string) values.nextElement();
				IntegerArray nodes = null;

				if (index != null)
				{
					nodes = (IntegerArray) index.get(token);
				}

				// If input was from W3C DOM, use DOM's getElementById to do
				// the look-up.
				if (nodes == null && _enhancedDOM != null && _enhancedDOM.hasDOMSource())
				{
					nodes = getDOMNodeById(token);
				}

				// Did we find the context node in the set of nodes?
				if (nodes != null && nodes.indexOf(node) >= 0)
				{
					return 1;
				}
			}

			// Didn't find the context node in the set of nodes returned by id
			return 0;
		}

		/// <summary>
		/// <para>Given a context node and the second argument to the XSLT
		/// <code>key</code> function, checks whether the context node is in the
		/// set of nodes that results from that reference to the <code>key</code>
		/// function.  This is used in the implementation of key patterns.</para>
		/// <para>This particular <seealso cref="KeyIndex"/> object is the result evaluating the
		/// first argument to the <code>key</code> function, so it's not taken into
		/// any further account.</para>
		/// </summary>
		/// <param name="node"> The context node </param>
		/// <param name="value"> The second argument to the <code>key</code> function </param>
		/// <returns> <code>1</code> if and only if the context node is in the set of
		///         nodes returned by the reference to the <code>key</code> function;
		///         <code>0</code>, otherwise </returns>
		public virtual int containsKey(int node, object value)
		{
			int rootHandle = _dom.getAxisIterator(Axis.ROOT).setStartNode(node).next();

			// Get the mapping table for the document containing the context node
			Hashtable index = (Hashtable) _rootToIndexMap.get(new int?(rootHandle));

			// Check whether the context node is present in the set of nodes
			// returned by the key function
			if (index != null)
			{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final org.apache.xalan.xsltc.util.IntegerArray nodes = (org.apache.xalan.xsltc.util.IntegerArray) index.get(value);
				IntegerArray nodes = (IntegerArray) index.get(value);
				return (nodes != null && nodes.indexOf(node) >= 0) ? 1 : 0;
			}

			// The particular key name identifies no nodes in this document
			return 0;
		}

		/// <summary>
		/// <para>Resets the iterator to the last start node.</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override DTMAxisIterator reset()
		{
		_position = 0;
		return this;
		}

		/// <summary>
		/// <para>Returns the number of elements in this iterator.</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override int Last
		{
			get
			{
			return (_nodes == null) ? 0 : _nodes.cardinality();
			}
		}

		/// <summary>
		/// <para>Returns the position of the current node in the set.</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override int Position
		{
			get
			{
			return _position;
			}
		}

		/// <summary>
		/// <para>Remembers the current node for the next call to gotoMark().</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override void setMark()
		{
		_markedPosition = _position;
		}

		/// <summary>
		/// <para>Restores the current node remembered by setMark().</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override void gotoMark()
		{
		_position = _markedPosition;
		}

		/// <summary>
		/// <para>Set start to END should 'close' the iterator, 
		/// i.e. subsequent call to next() should return END.</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override DTMAxisIterator setStartNode(int start)
		{
		if (start == DTMAxisIterator.END)
		{
			_nodes = null;
		}
		else if (_nodes != null)
		{
			_position = 0;
		}
		return (DTMAxisIterator) this;
		}

		/// <summary>
		/// <para>Get start to END should 'close' the iterator, 
		/// i.e. subsequent call to next() should return END.</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override int StartNode
		{
			get
			{
				return 0;
			}
		}

		/// <summary>
		/// <para>True if this iterator has a reversed axis.</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override bool Reverse
		{
			get
			{
			return (false);
			}
		}

		/// <summary>
		/// <para>Returns a deep copy of this iterator.</para>
		/// <para><em>Use of an instance of this class as a <seealso cref="DTMAxisIterator"/> is
		/// <b>deprecated.</b></em></para>
		/// @deprecated
		/// </summary>
		public override DTMAxisIterator cloneIterator()
		{
		KeyIndex other = new KeyIndex(0);
		other._index = _index;
			other._rootToIndexMap = _rootToIndexMap;
		other._nodes = _nodes;
		other._position = _position;
		return (DTMAxisIterator) other;
		}

		public virtual DOM Dom
		{
			set
			{
				_dom = value;
				if (value is DOMEnhancedForDTM)
				{
					_enhancedDOM = (DOMEnhancedForDTM)value;
				}
				else if (value is DOMAdapter)
				{
					DOM idom = ((DOMAdapter)value).DOMImpl;
					if (idom is DOMEnhancedForDTM)
					{
						_enhancedDOM = (DOMEnhancedForDTM)idom;
					}
				}
			}
		}

		/// <summary>
		/// Create a <seealso cref="KeyIndexIterator"/> that iterates over the nodes that
		/// result from a reference to the XSLT <code>key</code> function or
		/// XPath <code>id</code> function.
		/// </summary>
		/// <param name="keyValue"> A string or iterator representing the key values or id
		///                 references </param>
		/// <param name="isKeyCall"> A <code>boolean</code> indicating whether the iterator
		///                 is being created for a reference <code>key</code> or
		///                 <code>id</code> </param>
		public virtual KeyIndexIterator getKeyIndexIterator(object keyValue, bool isKeyCall)
		{
			if (keyValue is DTMAxisIterator)
			{
				return getKeyIndexIterator((DTMAxisIterator) keyValue, isKeyCall);
			}
			else
			{
				return getKeyIndexIterator(BasisLibrary.stringF(keyValue, _dom), isKeyCall);
			}
		}

		/// <summary>
		/// Create a <seealso cref="KeyIndexIterator"/> that iterates over the nodes that
		/// result from a reference to the XSLT <code>key</code> function or
		/// XPath <code>id</code> function.
		/// </summary>
		/// <param name="keyValue"> A string representing the key values or id
		///                 references </param>
		/// <param name="isKeyCall"> A <code>boolean</code> indicating whether the iterator
		///                 is being created for a reference <code>key</code> or
		///                 <code>id</code> </param>
		public virtual KeyIndexIterator getKeyIndexIterator(string keyValue, bool isKeyCall)
		{
			return new KeyIndexIterator(this, keyValue, isKeyCall);
		}

		/// <summary>
		/// Create a <seealso cref="KeyIndexIterator"/> that iterates over the nodes that
		/// result from a reference to the XSLT <code>key</code> function or
		/// XPath <code>id</code> function.
		/// </summary>
		/// <param name="keyValue"> An iterator representing the key values or id
		///                 references </param>
		/// <param name="isKeyCall"> A <code>boolean</code> indicating whether the iterator
		///                 is being created for a reference <code>key</code> or
		///                 <code>id</code> </param>
		public virtual KeyIndexIterator getKeyIndexIterator(DTMAxisIterator keyValue, bool isKeyCall)
		{
			return new KeyIndexIterator(this, keyValue, isKeyCall);
		}

		/// <summary>
		/// Used to represent an empty node set.
		/// </summary>
		private static readonly IntegerArray EMPTY_NODES = new IntegerArray(0);


		/// <summary>
		/// An iterator representing the result of a reference to either the
		/// XSLT <code>key</code> function or the XPath <code>id</code> function.
		/// </summary>
		public class KeyIndexIterator : MultiValuedNodeHeapIterator
		{
			private readonly KeyIndex outerInstance;


			/// <summary>
			/// <para>A reference to the <code>key</code> function that only has one
			/// key value or to the <code>id</code> function that has only one string
			/// argument can be optimized to ignore the multi-valued heap.  This
			/// field will be <code>null</code> otherwise.
			/// </para>
			/// </summary>
			internal IntegerArray _nodes;

			/// <summary>
			/// <para>This field contains the iterator representing a node set key value
			/// argument to the <code>key</code> function or a node set argument
			/// to the <code>id</code> function.</para>
			/// 
			/// <para>Exactly one of this field and <seealso cref="_keyValue"/> must be
			/// <code>null</code>.</para>
			/// </summary>
			internal DTMAxisIterator _keyValueIterator;

			/// <summary>
			/// <para>This field contains the iterator representing a non-node-set key
			/// value argument to the <code>key</code> function or a non-node-set
			/// argument to the <code>id</code> function.</para>
			/// 
			/// <para>Exactly one of this field and <seealso cref="_keyValueIterator"/> must be
			/// <code>null</code>.</para>
			/// </summary>
			internal string _keyValue;

			/// <summary>
			/// Indicates whether this object represents the result of a reference
			/// to the <code>key</code> function (<code>true</code>) or the
			/// <code>id</code> function (<code>false</code>).
			/// </summary>
			internal bool _isKeyIterator;

			/// <summary>
			/// Represents the DTM nodes retrieved for one key value or one string
			/// argument to <code>id</code> for use as one heap node in a
			/// <seealso cref="MultiValuedNodeHeapIterator"/>.
			/// </summary>
			protected internal class KeyIndexHeapNode : MultiValuedNodeHeapIterator.HeapNode
			{
				private readonly KeyIndex.KeyIndexIterator outerInstance;

				/// <summary>
				/// <seealso cref="IntegerArray"/> of DTM nodes retrieved for one key value.
				/// Must contain no duplicates and be stored in document order.
				/// </summary>
				internal IntegerArray _nodes;

				/// <summary>
				/// Position in <seealso cref="_nodes"/> array of next node to return from
				/// this heap node.
				/// </summary>
				internal int _position = 0;

				/// <summary>
				/// Marked position.  Used by <seealso cref="setMark()"/> and
				/// <seealso cref="gotoMark()"/>
				/// </summary>
				internal int _markPosition = -1;

				/// <summary>
				/// Create a heap node representing DTM nodes retrieved for one
				/// key value in a reference to the <code>key</code> function
				/// or string argument to the <code>id</code> function.
				/// </summary>
				internal KeyIndexHeapNode(KeyIndex.KeyIndexIterator outerInstance, IntegerArray nodes) : base(outerInstance)
				{
					this.outerInstance = outerInstance;
					_nodes = nodes;
				}

				/// <summary>
				/// Advance to the next node represented by this <seealso cref="HeapNode"/>
				/// </summary>
				/// <returns> the next DTM node. </returns>
				public override int step()
				{
					if (_position < _nodes.cardinality())
					{
						_node = _nodes.at(_position);
						_position++;
					}
					else
					{
						_node = DTMAxisIterator.END;
					}

					return _node;
				}

				/// <summary>
				/// Creates a deep copy of this <seealso cref="HeapNode"/>.  The clone is not
				/// reset from the current position of the original.
				/// </summary>
				/// <returns> the cloned heap node </returns>
				public override HeapNode cloneHeapNode()
				{
					KeyIndexHeapNode clone = (KeyIndexHeapNode) base.cloneHeapNode();

					clone._nodes = _nodes;
					clone._position = _position;
					clone._markPosition = _markPosition;

					return clone;
				}

				/// <summary>
				/// Remembers the current node for the next call to
				/// <seealso cref="gotoMark()"/>.
				/// </summary>
				public override void setMark()
				{
					_markPosition = _position;
				}

				/// <summary>
				/// Restores the current node remembered by <seealso cref="setMark()"/>.
				/// </summary>
				public override void gotoMark()
				{
					_position = _markPosition;
				}

				/// <summary>
				/// Performs a comparison of the two heap nodes
				/// </summary>
				/// <param name="heapNode"> the heap node against which to compare </param>
				/// <returns> <code>true</code> if and only if the current node for
				///         this heap node is before the current node of the
				///         argument heap node in document order. </returns>
				public override bool isLessThan(HeapNode heapNode)
				{
					return _node < heapNode._node;
				}

				/// <summary>
				/// <para>Sets context with respect to which this heap node is
				/// evaluated.</para>
				/// <para>This has no real effect on this kind of heap node.  Instead,
				/// the <seealso cref="KeyIndexIterator.setStartNode(int)"/> method should
				/// create new instances of this class to represent the effect of
				/// changing the context.</para>
				/// </summary>
				public override HeapNode setStartNode(int node)
				{
					return this;
				}

				/// <summary>
				/// Reset the heap node back to its beginning.
				/// </summary>
				public override HeapNode reset()
				{
					_position = 0;
					return this;
				}
			}

			/// <summary>
			/// Constructor used when the argument to <code>key</code> or
			/// <code>id</code> is not a node set.
			/// </summary>
			/// <param name="keyValue"> the argument to <code>key</code> or <code>id</code>
			///                 cast to a <code>String</code> </param>
			/// <param name="isKeyIterator"> indicates whether the constructed iterator
			///                represents a reference to <code>key</code> or
			///                <code>id</code>. </param>
			internal KeyIndexIterator(KeyIndex outerInstance, string keyValue, bool isKeyIterator)
			{
				this.outerInstance = outerInstance;
				_isKeyIterator = isKeyIterator;
				_keyValue = keyValue;
			}

			/// <summary>
			/// Constructor used when the argument to <code>key</code> or
			/// <code>id</code> is a node set.
			/// </summary>
			/// <param name="keyValues"> the argument to <code>key</code> or <code>id</code> </param>
			/// <param name="isKeyIterator"> indicates whether the constructed iterator
			///                represents a reference to <code>key</code> or
			///                <code>id</code>. </param>
			internal KeyIndexIterator(KeyIndex outerInstance, DTMAxisIterator keyValues, bool isKeyIterator)
			{
				this.outerInstance = outerInstance;
				_keyValueIterator = keyValues;
				_isKeyIterator = isKeyIterator;
			}

			/// <summary>
			/// Retrieve nodes for a particular key value or a particular id 
			/// argument value.
			/// </summary>
			/// <param name="root"> The root node of the document containing the context node </param>
			/// <param name="keyValue"> The key value of id string argument value </param>
			/// <returns> an <seealso cref="IntegerArray"/> of the resulting nodes </returns>
			protected internal virtual IntegerArray lookupNodes(int root, string keyValue)
			{
				IntegerArray result = null;

				// Get mapping from key values/IDs to DTM nodes for this document
				Hashtable index = (Hashtable)outerInstance._rootToIndexMap.get(new int?(root));

				if (!_isKeyIterator)
				{
					// For id function, tokenize argument as whitespace separated
					// list of values and look up nodes identified by each ID.
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final java.util.StringTokenizer values = new java.util.StringTokenizer(keyValue, " \n\t");
					StringTokenizer values = new StringTokenizer(keyValue, " \n\t");

					while (values.hasMoreElements())
					{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String token = (String) values.nextElement();
						string token = (string) values.nextElement();
						IntegerArray nodes = null;

						// Does the ID map to any node in the document?
						if (index != null)
						{
							nodes = (IntegerArray) index.get(token);
						}

						// If input was from W3C DOM, use DOM's getElementById to do
						// the look-up.
						if (nodes == null && outerInstance._enhancedDOM != null && outerInstance._enhancedDOM.hasDOMSource())
						{
							nodes = outerInstance.getDOMNodeById(token);
						}

						// If we found any nodes, merge them into the cumulative
						// result
						if (nodes != null)
						{
							if (result == null)
							{
								result = (IntegerArray)nodes.clone();
							}
							else
							{
								result.merge(nodes);
							}
						}
					}
				}
				else if (index != null)
				{
					// For key function, map key value to nodes
					result = (IntegerArray) index.get(keyValue);
				}

				return result;
			}

			/// <summary>
			/// Set context node for the iterator.  This will cause the iterator
			/// to reset itself, reevaluate arguments to the function, look up
			/// nodes in the input and reinitialize its internal heap.
			/// </summary>
			/// <param name="node"> the context node </param>
			/// <returns> A <seealso cref="DTMAxisIterator"/> set to the start of the iteration. </returns>
			public override DTMAxisIterator setStartNode(int node)
			{
				_startNode = node;

				// If the arugment to the function is a node set, set the
				// context node on it.
				if (_keyValueIterator != null)
				{
					_keyValueIterator = _keyValueIterator.setStartNode(node);
				}

				init();

				return base.setStartNode(node);
			}

			/// <summary>
			/// Get the next node in the iteration.
			/// </summary>
			/// <returns> The next node handle in the iteration, or END. </returns>
			public override int next()
			{
				int nodeHandle;

				// If at most one key value or at most one string argument to id
				// resulted in nodes being returned, use the IntegerArray
				// stored at _nodes directly.  This relies on the fact that the
				// IntegerArray never includes duplicate nodes and is always stored
				// in document order.
				if (_nodes != null)
				{
					if (_position < _nodes.cardinality())
					{
						nodeHandle = returnNode(_nodes.at(_position));
					}
					else
					{
						nodeHandle = DTMAxisIterator.END;
					}
				}
				else
				{
					nodeHandle = base.next();
				}

				return nodeHandle;
			}

			/// <summary>
			/// Resets the iterator to the last start node.
			/// </summary>
			/// <returns> A DTMAxisIterator, which may or may not be the same as this
			///         iterator. </returns>
			public override DTMAxisIterator reset()
			{
				if (_nodes == null)
				{
					init();
				}
				else
				{
					base.reset();
				}

				return resetPosition();
			}

			/// <summary>
			/// Evaluate the reference to the <code>key</code> or <code>id</code>
			/// function with the context specified by <seealso cref="setStartNode(int)"/>
			/// and set up this iterator to iterate over the DTM nodes that are
			/// to be returned.
			/// </summary>
			protected internal override void init()
			{
				base.init();
				_position = 0;

				// All nodes retrieved are in the same document
				int rootHandle = outerInstance._dom.getAxisIterator(Axis.ROOT).setStartNode(_startNode).next();

				// Is the argument not a node set?
				if (_keyValueIterator == null)
				{
					// Look up nodes returned for the single string argument
					_nodes = lookupNodes(rootHandle, _keyValue);

					if (_nodes == null)
					{
						_nodes = EMPTY_NODES;
					}
				}
				else
				{
					DTMAxisIterator keyValues = _keyValueIterator.reset();
					int retrievedKeyValueIdx = 0;
					bool foundNodes = false;

					_nodes = null;

					// For each node in the node set argument, get the string value
					// and look up the nodes returned by key or id for that string
					// value.  If at most one string value has nodes associated,
					// the nodes will be stored in _nodes; otherwise, the nodes
					// will be placed in a heap.
					for (int keyValueNode = keyValues.next(); keyValueNode != DTMAxisIterator.END; keyValueNode = keyValues.next())
					{

						string keyValue = BasisLibrary.stringF(keyValueNode, outerInstance._dom);

						IntegerArray nodes = lookupNodes(rootHandle, keyValue);

						if (nodes != null)
						{
							if (!foundNodes)
							{
								_nodes = nodes;
								foundNodes = true;
							}
							else
							{
								if (_nodes != null)
								{
									addHeapNode(new KeyIndexHeapNode(this, _nodes));
									_nodes = null;
								}
								addHeapNode(new KeyIndexHeapNode(this, nodes));
							}
						}
					}

					if (!foundNodes)
					{
						_nodes = EMPTY_NODES;
					}
				}
			}

			/// <summary>
			/// Returns the number of nodes in this iterator.
			/// </summary>
			/// <returns> the number of nodes </returns>
			public override int Last
			{
				get
				{
					// If nodes are stored in _nodes, take advantage of the fact that
					// there are no duplicates.  Otherwise, fall back to the base heap
					// implementaiton and hope it does a good job with this.
					return (_nodes != null) ? _nodes.cardinality() : base.Last;
				}
			}

			/// <summary>
			/// Return the node at the given position.
			/// </summary>
			/// <param name="position"> The position </param>
			/// <returns> The node at the given position. </returns>
			public override int getNodeByPosition(int position)
			{
				int node = DTMAxisIterator.END;

				// If nodes are stored in _nodes, take advantage of the fact that
				// there are no duplicates and they are stored in document order.
				// Otherwise, fall back to the base heap implementation to do a
				// good job with this.
				if (_nodes != null)
				{
					if (position > 0)
					{
						if (position <= _nodes.cardinality())
						{
							_position = position;
							node = _nodes.at(position - 1);
						}
						else
						{
							_position = _nodes.cardinality();
						}
					}
				}
				else
				{
					node = base.getNodeByPosition(position);
				}

				return node;
			}
		}
	}

}