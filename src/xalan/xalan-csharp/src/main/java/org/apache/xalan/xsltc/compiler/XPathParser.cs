using System;
using System.Collections;

//----------------------------------------------------
// The following code was generated by CUP v0.10k
// Wed Mar 26 09:57:43 EDT 2014
//----------------------------------------------------

namespace org.apache.xalan.xsltc.compiler
{
	using java_cup.runtime;
	using DTM = org.apache.xml.dtm.DTM;
	using DOM = org.apache.xalan.xsltc.DOM;
	using Axis = org.apache.xml.dtm.Axis;
	using Operators = org.apache.xalan.xsltc.runtime.Operators;
	using ErrorMsg = org.apache.xalan.xsltc.compiler.util.ErrorMsg;

	/// <summary>
	/// CUP v0.10k generated parser.
	/// @version Wed Mar 26 09:57:43 EDT 2014
	/// </summary>
	public class XPathParser : java_cup.runtime.lr_parser
	{

	  /// <summary>
	  /// Default constructor. </summary>
	  public XPathParser() : base()
	  {
	  }

	  /// <summary>
	  /// Constructor which sets the default scanner. </summary>
	  public XPathParser(java_cup.runtime.Scanner s) : base(s)
	  {
	  }

	  /// <summary>
	  /// Production table. </summary>
	  protected internal static readonly short[][] _production_table = unpackFromStrings(new string[] {"\x0000\x008D\x0000\x0002\x0002\x0004\x0000\x0002\x0003\x0004\x0000\x0002\x0003" + "\x0004\x0000\x0002\x001E\x0003\x0000\x0002\x001E\x0005\x0000\x0002\x001F\x0003" + "\x0000\x0002\x001F\x0004\x0000\x0002\x001F\x0003\x0000\x0002\x001F\x0005\x0000" + "\x0002\x001F\x0005\x0000\x0002\x001F\x0004\x0000\x0002\x001F\x0003\x0000\x0002" + "\x001D\x0006\x0000\x0002\x001D\x0008\x0000\x0002\x0020\x0006\x0000\x0002\x0021" + "\x0003\x0000\x0002\x0021\x0005\x0000\x0002\x0021\x0005\x0000\x0002\x0022\x0003" + "\x0000\x0002\x0022\x0004\x0000\x0002\x0022\x0003\x0000\x0002\x0022\x0004\x0000" + "\x0002\x0022\x0004\x0000\x0002\x0022\x0005\x0000\x0002\x0022\x0004\x0000\x0002" + "\x0022\x0005\x0000\x0002\x0023\x0003\x0000\x0002\x0023\x0003\x0000\x0002\x0023" + "\x0003\x0000\x0002\x0023\x0003\x0000\x0002\x0023\x0003\x0000\x0002\x0024\x0003" + "\x0000\x0002\x0024\x0003\x0000\x0002\x002C\x0003\x0000\x0002\x002C\x0004\x0000" + "\x0002\x002C\x0004\x0000\x0002\x0025\x0003\x0000\x0002\x0025\x0004\x0000\x0002" + "\x0007\x0005\x0000\x0002\x0004\x0003\x0000\x0002\x000A\x0003\x0000\x0002\x000A" + "\x0005\x0000\x0002\x000B\x0003\x0000\x0002\x000B\x0005\x0000\x0002\x000C\x0003" + "\x0000\x0002\x000C\x0005\x0000\x0002\x000C\x0005\x0000\x0002\x000D\x0003\x0000" + "\x0002\x000D\x0005\x0000\x0002\x000D\x0005\x0000\x0002\x000D\x0005\x0000\x0002" + "\x000D\x0005\x0000\x0002\x000E\x0003\x0000\x0002\x000E\x0005\x0000\x0002\x000E" + "\x0005\x0000\x0002\x000F\x0003\x0000\x0002\x000F\x0005\x0000\x0002\x000F\x0005" + "\x0000\x0002\x000F\x0005\x0000\x0002\x0010\x0003\x0000\x0002\x0010\x0004\x0000" + "\x0002\x0014\x0003\x0000\x0002\x0014\x0005\x0000\x0002\x0015\x0003\x0000\x0002" + "\x0015\x0003\x0000\x0002\x0015\x0005\x0000\x0002\x0015\x0005\x0000\x0002\x0006" + "\x0003\x0000\x0002\x0006\x0003\x0000\x0002\x0017\x0003\x0000\x0002\x0017\x0005" + "\x0000\x0002\x0017\x0003\x0000\x0002\x0019\x0003\x0000\x0002\x0019\x0004\x0000" + "\x0002\x0019\x0003\x0000\x0002\x0018\x0005\x0000\x0002\x001A\x0004\x0000\x0002" + "\x0009\x0003\x0000\x0002\x0009\x0004\x0000\x0002\x0009\x0005\x0000\x0002\x0009" + "\x0004\x0000\x0002\x0009\x0003\x0000\x0002\x002B\x0004\x0000\x0002\x002B\x0003" + "\x0000\x0002\x002A\x0003\x0000\x0002\x002A\x0003\x0000\x0002\x002A\x0003\x0000" + "\x0002\x002A\x0003\x0000\x0002\x002A\x0003\x0000\x0002\x002A\x0003\x0000\x0002" + "\x002A\x0003\x0000\x0002\x002A\x0003\x0000\x0002\x002A\x0003\x0000\x0002\x002A" + "\x0003\x0000\x0002\x002A\x0003\x0000\x0002\x002A\x0003\x0000\x0002\x002A\x0003" + "\x0000\x0002\x0016\x0003\x0000\x0002\x0016\x0003\x0000\x0002\x0008\x0003\x0000" + "\x0002\x0008\x0004\x0000\x0002\x0013\x0003\x0000\x0002\x0013\x0005\x0000\x0002" + "\x0013\x0003\x0000\x0002\x0013\x0003\x0000\x0002\x0013\x0003\x0000\x0002\x0013" + "\x0003\x0000\x0002\x0011\x0004\x0000\x0002\x0012\x0005\x0000\x0002\x0012\x0006" + "\x0000\x0002\x0026\x0003\x0000\x0002\x0026\x0005\x0000\x0002\x0028\x0003\x0000" + "\x0002\x0029\x0003\x0000\x0002\x0005\x0003\x0000\x0002\x001B\x0003\x0000\x0002" + "\x001B\x0003\x0000\x0002\x001B\x0003\x0000\x0002\x001B\x0003\x0000\x0002\x001B" + "\x0006\x0000\x0002\x001B\x0003\x0000\x0002\x001C\x0003\x0000\x0002\x001C\x0003" + "\x0000\x0002\x0027\x0003\x0000\x0002\x0027\x0003\x0000\x0002\x0027\x0003\x0000" + "\x0002\x0027\x0003\x0000\x0002\x0027\x0003\x0000\x0002\x0027\x0003\x0000\x0002" + "\x0027\x0003\x0000\x0002\x0027\x0003\x0000\x0002\x0027\x0003\x0000\x0002\x0027" + "\x0003\x0000\x0002\x0027\x0003\x0000\x0002\x0027\x0003\x0000\x0002\x0027\x0003" + "\x0000\x0002\x0027\x0003\x0000\x0002\x0027\x0003\x0000\x0002\x0027\x0003\x0000" + "\x0002\x0027\x0003\x0000\x0002\x0027\x0003"});

	  /// <summary>
	  /// Access to production table. </summary>
	  public virtual short[][] production_table()
	  {
		  return _production_table;
	  }

	  /// <summary>
	  /// Parse-action table. </summary>
	  protected internal static readonly short[][] _action_table = unpackFromStrings(new string[] {"\x0000\x00C7\x0000\x0006\x0037\x0006\x0038\x0005\x0001\x0002\x0000\x0004\x0002" + "\x00C9\x0001\x0002\x0000\x0048\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043" + "\x000D\x005C\x000E\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B" + "\x0020\x001D\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065" + "\x0025\x0033\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B" + "\x003F\x002C\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060" + "\x0032\x0037\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000" + "\x0038\x0004\x000B\x000B\x0017\x000E\x0010\x0011\x0013\x001A\x0019\x001B\x0020" + "\x001E\x001C\x001F\x001B\x0020\x0026\x0021\x0027\x0022\x0029\x0025\x000D\x0026" + "\x000C\x0027\x000E\x0028\x001E\x0029\x001F\x002A\x0024\x002B\x0015\x002C\x0028" + "\x002D\x0023\x002E\x0021\x002F\x001D\x0030\x0018\x0031\x0025\x0032\x0011\x0033" + "\x000A\x0034\x0022\x0001\x0002\x0000\x0006\x0002\ufffe\x0008\x00C6\x0001\x0002" + "\x0000\x0004\x0002\x0000\x0001\x0002\x0000\x000C\x0002\uffe7\x0004\uffe7\x0006" + "\uffe7\x0008\uffe7\x0011\uffe7\x0001\x0002\x0000\x002C\x0002\uff7a\x0004\uff7a" + "\x0006\uff7a\x0007\uff7a\x0008\uff7a\x000A\uff7a\x000C\uff7a\x0011\uff7a\x0012" + "\uff7a\x0013\uff7a\x0014\uff7a\x0015\uff7a\x0016\uff7a\x0017\uff7a\x0018\uff7a" + "\x0019\uff7a\x001A\uff7a\x001B\uff7a\x001C\uff7a\x0023\uff7a\x0024\uff7a\x0001" + "\x0002\x0000\x0038\x0002\ufffc\x0008\ufffc\x000B\x0017\x000E\x0010\x001A\x0019" + "\x001B\x0020\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0027\x0022\x0029\x0025" + "\x000D\x0026\x000C\x0027\x000E\x0028\x001E\x0029\x001F\x002A\x0024\x002B\x0015" + "\x002C\x0028\x002D\x0023\x002E\x0021\x002F\x001D\x0030\x0018\x0031\x0025\x0032" + "\x0011\x0033\x000A\x0034\x0022\x0001\x0002\x0000\x000C\x0002\uffe3\x0004\uffe3" + "\x0006\uffe3\x0008\uffe3\x0011\uffe3\x0001\x0002\x0000\x000C\x0002\uffe4\x0004" + "\uffe4\x0006\uffe4\x0008\uffe4\x0011\uffe4\x0001\x0002\x0000\x0004\x0009\x00C2" + "\x0001\x0002\x0000\x000A\x0002\ufffa\x0004\x00BF\x0008\ufffa\x0011\x00BE\x0001" + "\x0002\x0000\x0032\x000B\uffe0\x001A\uffe0\x001B\uffe0\x001E\uffe0\x001F\uffe0" + "\x0020\uffe0\x0021\uffe0\x0022\uffe0\x0025\uffe0\x0026\uffe0\x0027\uffe0\x0028" + "\uffe0\x0029\uffe0\x002A\uffe0\x002B\uffe0\x002C\uffe0\x002D\uffe0\x002E\uffe0" + "\x002F\uffe0\x0030\uffe0\x0031\uffe0\x0032\uffe0\x0033\uffe0\x0034\uffe0\x0001" + "\x0002\x0000\x002C\x0002\uff7b\x0004\uff7b\x0006\uff7b\x0007\uff7b\x0008\uff7b" + "\x000A\uff7b\x000C\uff7b\x0011\uff7b\x0012\uff7b\x0013\uff7b\x0014\uff7b\x0015" + "\uff7b\x0016\uff7b\x0017\uff7b\x0018\uff7b\x0019\uff7b\x001A\uff7b\x001B\uff7b" + "\x001C\uff7b\x0023\uff7b\x0024\uff7b\x0001\x0002\x0000\x0032\x000B\x0017\x001A" + "\x0019\x001B\x0020\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0027\x0022\x0029" + "\x0025\x000D\x0026\x000C\x0027\x000E\x0028\x001E\x0029\x001F\x002A\x0024\x002B" + "\x0078\x002C\x0076\x002D\x0023\x002E\x0021\x002F\x001D\x0030\x0018\x0031\x0025" + "\x0032\x0011\x0033\x000A\x0034\x0022\x0001\x0002\x0000\x0034\x000B\x0017\x000E" + "\x0010\x001A\x0019\x001B\x0020\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0027" + "\x0022\x0029\x0025\x000D\x0026\x000C\x0027\x000E\x0028\x001E\x0029\x001F\x002A" + "\x0024\x002B\x0015\x002C\x0028\x002D\x0023\x002E\x0021\x002F\x001D\x0030\x0018" + "\x0031\x0025\x0032\x0011\x0033\x000A\x0034\x0022\x0001\x0002\x0000\x000A\x0002" + "\ufff2\x0004\x00B6\x0008\ufff2\x0011\x00B5\x0001\x0002\x0000\x000E\x0002\uff7f" + "\x0004\uff7f\x0006\uff7f\x0008\uff7f\x0010\x00B4\x0011\uff7f\x0001\x0002\x0000" + "\x0006\x0002\ufff6\x0008\ufff6\x0001\x0002\x0000\x000C\x0002\uffe2\x0004\uffe2" + "\x0006\uffe2\x0008\uffe2\x0011\uffe2\x0001\x0002\x0000\x002C\x0002\uff7d\x0004" + "\uff7d\x0006\uff7d\x0007\uff7d\x0008\uff7d\x000A\uff7d\x000C\uff7d\x0011\uff7d" + "\x0012\uff7d\x0013\uff7d\x0014\uff7d\x0015\uff7d\x0016\uff7d\x0017\uff7d\x0018" + "\uff7d\x0019\uff7d\x001A\uff7d\x001B\uff7d\x001C\uff7d\x0023\uff7d\x0024\uff7d" + "\x0001\x0002\x0000\x002E\x0002\uff85\x0004\uff85\x0006\uff85\x0007\uff85\x0008" + "\uff85\x0009\uff85\x000A\uff85\x000C\uff85\x0011\uff85\x0012\uff85\x0013\uff85" + "\x0014\uff85\x0015\uff85\x0016\uff85\x0017\uff85\x0018\uff85\x0019\uff85\x001A" + "\uff85\x001B\uff85\x001C\uff85\x0023\uff85\x0024\uff85\x0001\x0002\x0000\x000C" + "\x0002\uffed\x0004\uffed\x0006\x002D\x0008\uffed\x0011\uffed\x0001\x0002\x0000" + "\x000E\x0002\uff75\x0004\uff75\x0006\uff75\x0008\uff75\x0009\x00B0\x0011\uff75" + "\x0001\x0002\x0000\x002E\x0002\uff86\x0004\uff86\x0006\uff86\x0007\uff86\x0008" + "\uff86\x0009\uff86\x000A\uff86\x000C\uff86\x0011\uff86\x0012\uff86\x0013\uff86" + "\x0014\uff86\x0015\uff86\x0016\uff86\x0017\uff86\x0018\uff86\x0019\uff86\x001A" + "\uff86\x001B\uff86\x001C\uff86\x0023\uff86\x0024\uff86\x0001\x0002\x0000\x002C" + "\x0002\uff7e\x0004\uff7e\x0006\uff7e\x0007\uff7e\x0008\uff7e\x000A\uff7e\x000C" + "\uff7e\x0011\uff7e\x0012\uff7e\x0013\uff7e\x0014\uff7e\x0015\uff7e\x0016\uff7e" + "\x0017\uff7e\x0018\uff7e\x0019\uff7e\x001A\uff7e\x001B\uff7e\x001C\uff7e\x0023" + "\uff7e\x0024\uff7e\x0001\x0002\x0000\x002C\x0002\uff77\x0004\uff77\x0006\uff77" + "\x0007\uff77\x0008\uff77\x000A\uff77\x000C\uff77\x0011\uff77\x0012\uff77\x0013" + "\uff77\x0014\uff77\x0015\uff77\x0016\uff77\x0017\uff77\x0018\uff77\x0019\uff77" + "\x001A\uff77\x001B\uff77\x001C\uff77\x0023\uff77\x0024\uff77\x0001\x0002\x0000" + "\x002C\x0002\uff76\x0004\uff76\x0006\uff76\x0007\uff76\x0008\uff76\x000A\uff76" + "\x000C\uff76\x0011\uff76\x0012\uff76\x0013\uff76\x0014\uff76\x0015\uff76\x0016" + "\uff76\x0017\uff76\x0018\uff76\x0019\uff76\x001A\uff76\x001B\uff76\x001C\uff76" + "\x0023\uff76\x0024\uff76\x0001\x0002\x0000\x002E\x0002\uff84\x0004\uff84\x0006" + "\uff84\x0007\uff84\x0008\uff84\x0009\uff84\x000A\uff84\x000C\uff84\x0011\uff84" + "\x0012\uff84\x0013\uff84\x0014\uff84\x0015\uff84\x0016\uff84\x0017\uff84\x0018" + "\uff84\x0019\uff84\x001A\uff84\x001B\uff84\x001C\uff84\x0023\uff84\x0024\uff84" + "\x0001\x0002\x0000\x002C\x0002\uff81\x0004\uff81\x0006\uff81\x0007\uff81\x0008" + "\uff81\x000A\uff81\x000C\uff81\x0011\uff81\x0012\uff81\x0013\uff81\x0014\uff81" + "\x0015\uff81\x0016\uff81\x0017\uff81\x0018\uff81\x0019\uff81\x001A\uff81\x001B" + "\uff81\x001C\uff81\x0023\uff81\x0024\uff81\x0001\x0002\x0000\x002C\x0002\uff78" + "\x0004\uff78\x0006\uff78\x0007\uff78\x0008\uff78\x000A\uff78\x000C\uff78\x0011" + "\uff78\x0012\uff78\x0013\uff78\x0014\uff78\x0015\uff78\x0016\uff78\x0017\uff78" + "\x0018\uff78\x0019\uff78\x001A\uff78\x001B\uff78\x001C\uff78\x0023\uff78\x0024" + "\uff78\x0001\x0002\x0000\x002C\x0002\uff82\x0004\uff82\x0006\uff82\x0007\uff82" + "\x0008\uff82\x000A\uff82\x000C\uff82\x0011\uff82\x0012\uff82\x0013\uff82\x0014" + "\uff82\x0015\uff82\x0016\uff82\x0017\uff82\x0018\uff82\x0019\uff82\x001A\uff82" + "\x001B\uff82\x001C\uff82\x0023\uff82\x0024\uff82\x0001\x0002\x0000\x002C\x0002" + "\uff79\x0004\uff79\x0006\uff79\x0007\uff79\x0008\uff79\x000A\uff79\x000C\uff79" + "\x0011\uff79\x0012\uff79\x0013\uff79\x0014\uff79\x0015\uff79\x0016\uff79\x0017" + "\uff79\x0018\uff79\x0019\uff79\x001A\uff79\x001B\uff79\x001C\uff79\x0023\uff79" + "\x0024\uff79\x0001\x0002\x0000\x002C\x0002\uff7c\x0004\uff7c\x0006\uff7c\x0007" + "\uff7c\x0008\uff7c\x000A\uff7c\x000C\uff7c\x0011\uff7c\x0012\uff7c\x0013\uff7c" + "\x0014\uff7c\x0015\uff7c\x0016\uff7c\x0017\uff7c\x0018\uff7c\x0019\uff7c\x001A" + "\uff7c\x001B\uff7c\x001C\uff7c\x0023\uff7c\x0024\uff7c\x0001\x0002\x0000\x000E" + "\x0002\uff83\x0004\uff83\x0006\uff83\x0008\uff83\x0009\x00AB\x0011\uff83\x0001" + "\x0002\x0000\x000C\x0002\uffe5\x0004\uffe5\x0006\uffe5\x0008\uffe5\x0011\uffe5" + "\x0001\x0002\x0000\x000E\x0002\uff80\x0004\uff80\x0006\uff80\x0008\uff80\x0010" + "\x00AA\x0011\uff80\x0001\x0002\x0000\x000C\x0002\uffe6\x0004\uffe6\x0006\uffe6" + "\x0008\uffe6\x0011\uffe6\x0001\x0002\x0000\x000C\x0002\uffe1\x0004\uffe1\x0006" + "\uffe1\x0008\uffe1\x0011\uffe1\x0001\x0002\x0000\x000C\x0002\uffef\x0004\uffef" + "\x0006\x002D\x0008\uffef\x0011\uffef\x0001\x0002\x0000\x002C\x0002\uffdd\x0004" + "\uffdd\x0006\x002D\x0007\uffdd\x0008\uffdd\x000A\uffdd\x000C\uffdd\x0011\uffdd" + "\x0012\uffdd\x0013\uffdd\x0014\uffdd\x0015\uffdd\x0016\uffdd\x0017\uffdd\x0018" + "\uffdd\x0019\uffdd\x001A\uffdd\x001B\uffdd\x001C\uffdd\x0023\uffdd\x0024\uffdd" + "\x0001\x0002\x0000\x0048\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043\x000D" + "\x005C\x000E\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B\x0020" + "\x001D\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025" + "\x0033\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F" + "\x002C\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032" + "\x0037\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x000A" + "\x0002\uffee\x0004\uffee\x0008\uffee\x0011\uffee\x0001\x0002\x0000\x002C\x0002" + "\uff9a\x0004\uff9a\x0006\uff9a\x0007\uff9a\x0008\uff9a\x000A\uff9a\x000C\uff9a" + "\x0011\uff9a\x0012\uff9a\x0013\uff9a\x0014\uff9a\x0015\uff9a\x0016\uff9a\x0017" + "\uff9a\x0018\uff9a\x0019\uff9a\x001A\uff9a\x001B\uff9a\x001C\uff9a\x0023\uff9a" + "\x0024\uff9a\x0001\x0002\x0000\x0030\x0002\uff7a\x0004\uff7a\x0006\uff7a\x0007" + "\uff7a\x0008\uff7a\x0009\uff7a\x000A\uff7a\x000C\uff7a\x0010\uffa5\x0011\uff7a" + "\x0012\uff7a\x0013\uff7a\x0014\uff7a\x0015\uff7a\x0016\uff7a\x0017\uff7a\x0018" + "\uff7a\x0019\uff7a\x001A\uff7a\x001B\uff7a\x001C\uff7a\x0023\uff7a\x0024\uff7a" + "\x0001\x0002\x0000\x0058\x0002\uffb9\x0005\x0049\x0007\uffb9\x0008\uffb9\x000A" + "\uffb9\x000B\x0043\x000C\uffb9\x000E\x0036\x000F\x0046\x0012\uffb9\x0013\uffb9" + "\x0014\uffb9\x0015\uffb9\x0016\uffb9\x0017\uffb9\x0018\uffb9\x0019\uffb9\x001A" + "\x0019\x001B\x0020\x001C\uffb9\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062" + "\x0022\x0065\x0023\uffb9\x0024\uffb9\x0025\x0033\x0026\x0032\x0027\x0035\x0028" + "\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055" + "\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0001" + "\x0002\x0000\x002C\x0002\uff89\x0004\uff89\x0006\uff89\x0007\uff89\x0008\uff89" + "\x000A\uff89\x000C\uff89\x0011\uff89\x0012\uff89\x0013\uff89\x0014\uff89\x0015" + "\uff89\x0016\uff89\x0017\uff89\x0018\uff89\x0019\uff89\x001A\uff89\x001B\uff89" + "\x001C\uff89\x0023\uff89\x0024\uff89\x0001\x0002\x0000\x002C\x0002\uff8b\x0004" + "\uff8b\x0006\uff8b\x0007\uff8b\x0008\uff8b\x000A\uff8b\x000C\uff8b\x0011\uff8b" + "\x0012\uff8b\x0013\uff8b\x0014\uff8b\x0015\uff8b\x0016\uff8b\x0017\uff8b\x0018" + "\uff8b\x0019\uff8b\x001A\uff8b\x001B\uff8b\x001C\uff8b\x0023\uff8b\x0024\uff8b" + "\x0001\x0002\x0000\x001A\x0002\uffd5\x0007\uffd5\x000A\uffd5\x000C\uffd5\x0012" + "\uffd5\x0013\uffd5\x0014\x0091\x0015\x0092\x0016\x0093\x0017\x0094\x0023\uffd5" + "\x0024\uffd5\x0001\x0002\x0000\x0004\x0009\x00A5\x0001\x0002\x0000\x0032\x000B" + "\uffae\x001A\uffae\x001B\uffae\x001E\uffae\x001F\uffae\x0020\uffae\x0021\uffae" + "\x0022\uffae\x0025\uffae\x0026\uffae\x0027\uffae\x0028\uffae\x0029\uffae\x002A" + "\uffae\x002B\uffae\x002C\uffae\x002D\uffae\x002E\uffae\x002F\uffae\x0030\uffae" + "\x0031\uffae\x0032\uffae\x0033\uffae\x0034\uffae\x0001\x0002\x0000\x0030\x0002" + "\uff7b\x0004\uff7b\x0006\uff7b\x0007\uff7b\x0008\uff7b\x0009\uff7b\x000A\uff7b" + "\x000C\uff7b\x0010\uffa6\x0011\uff7b\x0012\uff7b\x0013\uff7b\x0014\uff7b\x0015" + "\uff7b\x0016\uff7b\x0017\uff7b\x0018\uff7b\x0019\uff7b\x001A\uff7b\x001B\uff7b" + "\x001C\uff7b\x0023\uff7b\x0024\uff7b\x0001\x0002\x0000\x0038\x0005\x0049\x000B" + "\x0043\x000E\x0036\x000F\x0046\x001A\x0019\x001B\x0020\x001E\x001C\x001F\x004B" + "\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028" + "\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055" + "\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0001" + "\x0002\x0000\x0048\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C" + "\x000E\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D" + "\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033" + "\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C" + "\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037" + "\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x002C\x0002" + "\uff99\x0004\uff99\x0006\uff99\x0007\uff99\x0008\uff99\x000A\uff99\x000C\uff99" + "\x0011\uff99\x0012\uff99\x0013\uff99\x0014\uff99\x0015\uff99\x0016\uff99\x0017" + "\uff99\x0018\uff99\x0019\uff99\x001A\uff99\x001B\uff99\x001C\uff99\x0023\uff99" + "\x0024\uff99\x0001\x0002\x0000\x0026\x0002\uffb7\x0007\uffb7\x0008\uffb7\x000A" + "\uffb7\x000C\uffb7\x0012\uffb7\x0013\uffb7\x0014\uffb7\x0015\uffb7\x0016\uffb7" + "\x0017\uffb7\x0018\uffb7\x0019\uffb7\x001A\uffb7\x001B\uffb7\x001C\uffb7\x0023" + "\uffb7\x0024\uffb7\x0001\x0002\x0000\x002C\x0002\uff97\x0004\uff97\x0006\uff97" + "\x0007\uff97\x0008\uff97\x000A\uff97\x000C\uff97\x0011\uff97\x0012\uff97\x0013" + "\uff97\x0014\uff97\x0015\uff97\x0016\uff97\x0017\uff97\x0018\uff97\x0019\uff97" + "\x001A\uff97\x001B\uff97\x001C\uff97\x0023\uff97\x0024\uff97\x0001\x0002\x0000" + "\x0048\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C\x000E\x0036" + "\x000F\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D\x002F\x001E" + "\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032" + "\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D" + "\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030" + "\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x000E\x0002\uffd9\x0007" + "\uffd9\x000A\uffd9\x000C\uffd9\x0023\uffd9\x0024\x009C\x0001\x0002\x0000\x0030" + "\x0002\uff7f\x0004\uff7f\x0006\uff7f\x0007\uff7f\x0008\uff7f\x0009\uff7f\x000A" + "\uff7f\x000C\uff7f\x0010\uffaa\x0011\uff7f\x0012\uff7f\x0013\uff7f\x0014\uff7f" + "\x0015\uff7f\x0016\uff7f\x0017\uff7f\x0018\uff7f\x0019\uff7f\x001A\uff7f\x001B" + "\uff7f\x001C\uff7f\x0023\uff7f\x0024\uff7f\x0001\x0002\x0000\x0032\x000B\x0043" + "\x001A\x0019\x001B\x0020\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022" + "\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028\x001E\x0029\x001F\x002A\x0024" + "\x002B\x0078\x002C\x0076\x002D\x0023\x002E\x0021\x002F\x001D\x0030\x0018\x0031" + "\x0025\x0032\x0011\x0033\x000A\x0034\x0022\x0001\x0002\x0000\x0004\x0010\x009E" + "\x0001\x0002\x0000\x000C\x0002\uffda\x0007\uffda\x000A\uffda\x000C\uffda\x0023" + "\x009A\x0001\x0002\x0000\x002C\x0002\uff88\x0004\uff88\x0006\uff88\x0007\uff88" + "\x0008\uff88\x000A\uff88\x000C\uff88\x0011\uff88\x0012\uff88\x0013\uff88\x0014" + "\uff88\x0015\uff88\x0016\uff88\x0017\uff88\x0018\uff88\x0019\uff88\x001A\uff88" + "\x001B\uff88\x001C\uff88\x0023\uff88\x0024\uff88\x0001\x0002\x0000\x0030\x0002" + "\uff7d\x0004\uff7d\x0006\uff7d\x0007\uff7d\x0008\uff7d\x0009\uff7d\x000A\uff7d" + "\x000C\uff7d\x0010\uffa8\x0011\uff7d\x0012\uff7d\x0013\uff7d\x0014\uff7d\x0015" + "\uff7d\x0016\uff7d\x0017\uff7d\x0018\uff7d\x0019\uff7d\x001A\uff7d\x001B\uff7d" + "\x001C\uff7d\x0023\uff7d\x0024\uff7d\x0001\x0002\x0000\x0012\x0002\uffd7\x0007" + "\uffd7\x000A\uffd7\x000C\uffd7\x0012\x008E\x0013\x008F\x0023\uffd7\x0024\uffd7" + "\x0001\x0002\x0000\x002A\x0002\uff9f\x0004\uff9f\x0007\uff9f\x0008\uff9f\x000A" + "\uff9f\x000C\uff9f\x0011\uff9f\x0012\uff9f\x0013\uff9f\x0014\uff9f\x0015\uff9f" + "\x0016\uff9f\x0017\uff9f\x0018\uff9f\x0019\uff9f\x001A\uff9f\x001B\uff9f\x001C" + "\uff9f\x0023\uff9f\x0024\uff9f\x0001\x0002\x0000\x002C\x0002\uffb4\x0004\uffb4" + "\x0006\x002D\x0007\uffb4\x0008\uffb4\x000A\uffb4\x000C\uffb4\x0011\uffb4\x0012" + "\uffb4\x0013\uffb4\x0014\uffb4\x0015\uffb4\x0016\uffb4\x0017\uffb4\x0018\uffb4" + "\x0019\uffb4\x001A\uffb4\x001B\uffb4\x001C\uffb4\x0023\uffb4\x0024\uffb4\x0001" + "\x0002\x0000\x0026\x0002\uffbd\x0007\uffbd\x0008\uffbd\x000A\uffbd\x000C\uffbd" + "\x0012\uffbd\x0013\uffbd\x0014\uffbd\x0015\uffbd\x0016\uffbd\x0017\uffbd\x0018" + "\uffbd\x0019\uffbd\x001A\uffbd\x001B\uffbd\x001C\uffbd\x0023\uffbd\x0024\uffbd" + "\x0001\x0002\x0000\x002A\x0002\uffa0\x0004\uffa0\x0007\uffa0\x0008\uffa0\x000A" + "\uffa0\x000C\uffa0\x0011\uffa0\x0012\uffa0\x0013\uffa0\x0014\uffa0\x0015\uffa0" + "\x0016\uffa0\x0017\uffa0\x0018\uffa0\x0019\uffa0\x001A\uffa0\x001B\uffa0\x001C" + "\uffa0\x0023\uffa0\x0024\uffa0\x0001\x0002\x0000\x001E\x0002\uffd2\x0007\uffd2" + "\x000A\uffd2\x000C\uffd2\x0012\uffd2\x0013\uffd2\x0014\uffd2\x0015\uffd2\x0016" + "\uffd2\x0017\uffd2\x0018\x0089\x0019\x008A\x0023\uffd2\x0024\uffd2\x0001\x0002" + "\x0000\x002E\x0002\uff75\x0004\uff75\x0006\uff75\x0007\uff75\x0008\uff75\x0009" + "\uff75\x000A\uff75\x000C\uff75\x0011\uff75\x0012\uff75\x0013\uff75\x0014\uff75" + "\x0015\uff75\x0016\uff75\x0017\uff75\x0018\uff75\x0019\uff75\x001A\uff75\x001B" + "\uff75\x001C\uff75\x0023\uff75\x0024\uff75\x0001\x0002\x0000\x0024\x0002\uffca" + "\x0007\uffca\x000A\uffca\x000C\uffca\x0012\uffca\x0013\uffca\x0014\uffca\x0015" + "\uffca\x0016\uffca\x0017\uffca\x0018\uffca\x0019\uffca\x001A\uffca\x001B\uffca" + "\x001C\uffca\x0023\uffca\x0024\uffca\x0001\x0002\x0000\x0030\x0002\uff77\x0004" + "\uff77\x0006\uff77\x0007\uff77\x0008\uff77\x0009\uff77\x000A\uff77\x000C\uff77" + "\x0010\uffa2\x0011\uff77\x0012\uff77\x0013\uff77\x0014\uff77\x0015\uff77\x0016" + "\uff77\x0017\uff77\x0018\uff77\x0019\uff77\x001A\uff77\x001B\uff77\x001C\uff77" + "\x0023\uff77\x0024\uff77\x0001\x0002\x0000\x0030\x0002\uff7e\x0004\uff7e\x0006" + "\uff7e\x0007\uff7e\x0008\uff7e\x0009\uff7e\x000A\uff7e\x000C\uff7e\x0010\uffa9" + "\x0011\uff7e\x0012\uff7e\x0013\uff7e\x0014\uff7e\x0015\uff7e\x0016\uff7e\x0017" + "\uff7e\x0018\uff7e\x0019\uff7e\x001A\uff7e\x001B\uff7e\x001C\uff7e\x0023\uff7e" + "\x0024\uff7e\x0001\x0002\x0000\x0004\x0009\x0081\x0001\x0002\x0000\x002A\x0002" + "\uffbc\x0004\uffbc\x0007\uffbc\x0008\uffbc\x000A\uffbc\x000C\uffbc\x0011\uffbc" + "\x0012\uffbc\x0013\uffbc\x0014\uffbc\x0015\uffbc\x0016\uffbc\x0017\uffbc\x0018" + "\uffbc\x0019\uffbc\x001A\uffbc\x001B\uffbc\x001C\uffbc\x0023\uffbc\x0024\uffbc" + "\x0001\x0002\x0000\x0026\x0002\uffc2\x0007\uffc2\x0008\uffc2\x000A\uffc2\x000C" + "\uffc2\x0012\uffc2\x0013\uffc2\x0014\uffc2\x0015\uffc2\x0016\uffc2\x0017\uffc2" + "\x0018\uffc2\x0019\uffc2\x001A\uffc2\x001B\uffc2\x001C\uffc2\x0023\uffc2\x0024" + "\uffc2\x0001\x0002\x0000\x002C\x0002\uff9e\x0004\uff9e\x0006\x002D\x0007\uff9e" + "\x0008\uff9e\x000A\uff9e\x000C\uff9e\x0011\uff9e\x0012\uff9e\x0013\uff9e\x0014" + "\uff9e\x0015\uff9e\x0016\uff9e\x0017\uff9e\x0018\uff9e\x0019\uff9e\x001A\uff9e" + "\x001B\uff9e\x001C\uff9e\x0023\uff9e\x0024\uff9e\x0001\x0002\x0000\x0030\x0002" + "\uff76\x0004\uff76\x0006\uff76\x0007\uff76\x0008\uff76\x0009\uff76\x000A\uff76" + "\x000C\uff76\x0010\uffa1\x0011\uff76\x0012\uff76\x0013\uff76\x0014\uff76\x0015" + "\uff76\x0016\uff76\x0017\uff76\x0018\uff76\x0019\uff76\x001A\uff76\x001B\uff76" + "\x001C\uff76\x0023\uff76\x0024\uff76\x0001\x0002\x0000\x0026\x0002\uffc4\x0007" + "\uffc4\x0008\x007E\x000A\uffc4\x000C\uffc4\x0012\uffc4\x0013\uffc4\x0014\uffc4" + "\x0015\uffc4\x0016\uffc4\x0017\uffc4\x0018\uffc4\x0019\uffc4\x001A\uffc4\x001B" + "\uffc4\x001C\uffc4\x0023\uffc4\x0024\uffc4\x0001\x0002\x0000\x0030\x0002\uff81" + "\x0004\uff81\x0006\uff81\x0007\uff81\x0008\uff81\x0009\uff81\x000A\uff81\x000C" + "\uff81\x0010\uffac\x0011\uff81\x0012\uff81\x0013\uff81\x0014\uff81\x0015\uff81" + "\x0016\uff81\x0017\uff81\x0018\uff81\x0019\uff81\x001A\uff81\x001B\uff81\x001C" + "\uff81\x0023\uff81\x0024\uff81\x0001\x0002\x0000\x002C\x0002\uff9c\x0004\uff9c" + "\x0006\uff9c\x0007\uff9c\x0008\uff9c\x000A\uff9c\x000C\uff9c\x0011\uff9c\x0012" + "\uff9c\x0013\uff9c\x0014\uff9c\x0015\uff9c\x0016\uff9c\x0017\uff9c\x0018\uff9c" + "\x0019\uff9c\x001A\uff9c\x001B\uff9c\x001C\uff9c\x0023\uff9c\x0024\uff9c\x0001" + "\x0002\x0000\x0030\x0002\uff78\x0004\uff78\x0006\uff78\x0007\uff78\x0008\uff78" + "\x0009\uff78\x000A\uff78\x000C\uff78\x0010\uffa3\x0011\uff78\x0012\uff78\x0013" + "\uff78\x0014\uff78\x0015\uff78\x0016\uff78\x0017\uff78\x0018\uff78\x0019\uff78" + "\x001A\uff78\x001B\uff78\x001C\uff78\x0023\uff78\x0024\uff78\x0001\x0002\x0000" + "\x002A\x0002\uffc1\x0004\x007B\x0007\uffc1\x0008\uffc1\x000A\uffc1\x000C\uffc1" + "\x0011\x007A\x0012\uffc1\x0013\uffc1\x0014\uffc1\x0015\uffc1\x0016\uffc1\x0017" + "\uffc1\x0018\uffc1\x0019\uffc1\x001A\uffc1\x001B\uffc1\x001C\uffc1\x0023\uffc1" + "\x0024\uffc1\x0001\x0002\x0000\x0030\x0002\uff82\x0004\uff82\x0006\uff82\x0007" + "\uff82\x0008\uff82\x0009\uff82\x000A\uff82\x000C\uff82\x0010\uffad\x0011\uff82" + "\x0012\uff82\x0013\uff82\x0014\uff82\x0015\uff82\x0016\uff82\x0017\uff82\x0018" + "\uff82\x0019\uff82\x001A\uff82\x001B\uff82\x001C\uff82\x0023\uff82\x0024\uff82" + "\x0001\x0002\x0000\x002C\x0002\uff98\x0004\uff98\x0006\uff98\x0007\uff98\x0008" + "\uff98\x000A\uff98\x000C\uff98\x0011\uff98\x0012\uff98\x0013\uff98\x0014\uff98" + "\x0015\uff98\x0016\uff98\x0017\uff98\x0018\uff98\x0019\uff98\x001A\uff98\x001B" + "\uff98\x001C\uff98\x0023\uff98\x0024\uff98\x0001\x0002\x0000\x0004\x0007\x0079" + "\x0001\x0002\x0000\x0026\x001A\x0019\x001B\x0020\x001E\x001C\x001F\x004B\x0020" + "\x0061\x0028\x001E\x0029\x001F\x002A\x0024\x002B\x0078\x002C\x0076\x002D\x0023" + "\x002E\x0021\x002F\x001D\x0030\x0018\x0031\x0025\x0032\x0011\x0033\x000A\x0034" + "\x0022\x0001\x0002\x0000\x002A\x0002\uffba\x0004\uffba\x0007\uffba\x0008\uffba" + "\x000A\uffba\x000C\uffba\x0011\uffba\x0012\uffba\x0013\uffba\x0014\uffba\x0015" + "\uffba\x0016\uffba\x0017\uffba\x0018\uffba\x0019\uffba\x001A\uffba\x001B\uffba" + "\x001C\uffba\x0023\uffba\x0024\uffba\x0001\x0002\x0000\x0030\x0002\uff79\x0004" + "\uff79\x0006\uff79\x0007\uff79\x0008\uff79\x0009\uff79\x000A\uff79\x000C\uff79" + "\x0010\uffa4\x0011\uff79\x0012\uff79\x0013\uff79\x0014\uff79\x0015\uff79\x0016" + "\uff79\x0017\uff79\x0018\uff79\x0019\uff79\x001A\uff79\x001B\uff79\x001C\uff79" + "\x0023\uff79\x0024\uff79\x0001\x0002\x0000\x002A\x0002\uffb0\x0004\uffb0\x0007" + "\uffb0\x0008\uffb0\x000A\uffb0\x000C\uffb0\x0011\uffb0\x0012\uffb0\x0013\uffb0" + "\x0014\uffb0\x0015\uffb0\x0016\uffb0\x0017\uffb0\x0018\uffb0\x0019\uffb0\x001A" + "\uffb0\x001B\uffb0\x001C\uffb0\x0023\uffb0\x0024\uffb0\x0001\x0002\x0000\x0030" + "\x0002\uff7c\x0004\uff7c\x0006\uff7c\x0007\uff7c\x0008\uff7c\x0009\uff7c\x000A" + "\uff7c\x000C\uff7c\x0010\uffa7\x0011\uff7c\x0012\uff7c\x0013\uff7c\x0014\uff7c" + "\x0015\uff7c\x0016\uff7c\x0017\uff7c\x0018\uff7c\x0019\uff7c\x001A\uff7c\x001B" + "\uff7c\x001C\uff7c\x0023\uff7c\x0024\uff7c\x0001\x0002\x0000\x002E\x0002\uff83" + "\x0004\uff83\x0006\uff83\x0007\uff83\x0008\uff83\x0009\uff83\x000A\uff83\x000C" + "\uff83\x0011\uff83\x0012\uff83\x0013\uff83\x0014\uff83\x0015\uff83\x0016\uff83" + "\x0017\uff83\x0018\uff83\x0019\uff83\x001A\uff83\x001B\uff83\x001C\uff83\x0023" + "\uff83\x0024\uff83\x0001\x0002\x0000\x002C\x0002\uff8c\x0004\uff8c\x0006\uff8c" + "\x0007\uff8c\x0008\uff8c\x000A\uff8c\x000C\uff8c\x0011\uff8c\x0012\uff8c\x0013" + "\uff8c\x0014\uff8c\x0015\uff8c\x0016\uff8c\x0017\uff8c\x0018\uff8c\x0019\uff8c" + "\x001A\uff8c\x001B\uff8c\x001C\uff8c\x0023\uff8c\x0024\uff8c\x0001\x0002\x0000" + "\x0030\x0002\uff80\x0004\uff80\x0006\uff80\x0007\uff80\x0008\uff80\x0009\uff80" + "\x000A\uff80\x000C\uff80\x0010\uffab\x0011\uff80\x0012\uff80\x0013\uff80\x0014" + "\uff80\x0015\uff80\x0016\uff80\x0017\uff80\x0018\uff80\x0019\uff80\x001A\uff80" + "\x001B\uff80\x001C\uff80\x0023\uff80\x0024\uff80\x0001\x0002\x0000\x0024\x0002" + "\uffc6\x0007\uffc6\x000A\uffc6\x000C\uffc6\x0012\uffc6\x0013\uffc6\x0014\uffc6" + "\x0015\uffc6\x0016\uffc6\x0017\uffc6\x0018\uffc6\x0019\uffc6\x001A\uffc6\x001B" + "\uffc6\x001C\uffc6\x0023\uffc6\x0024\uffc6\x0001\x0002\x0000\x002C\x0002\uff8d" + "\x0004\uff8d\x0006\uff8d\x0007\uff8d\x0008\uff8d\x000A\uff8d\x000C\uff8d\x0011" + "\uff8d\x0012\uff8d\x0013\uff8d\x0014\uff8d\x0015\uff8d\x0016\uff8d\x0017\uff8d" + "\x0018\uff8d\x0019\uff8d\x001A\uff8d\x001B\uff8d\x001C\uff8d\x0023\uff8d\x0024" + "\uff8d\x0001\x0002\x0000\x0024\x0002\uffcd\x0007\uffcd\x000A\uffcd\x000C\uffcd" + "\x0012\uffcd\x0013\uffcd\x0014\uffcd\x0015\uffcd\x0016\uffcd\x0017\uffcd\x0018" + "\uffcd\x0019\uffcd\x001A\x0071\x001B\x006F\x001C\x0070\x0023\uffcd\x0024\uffcd" + "\x0001\x0002\x0000\x002A\x0002\uffbe\x0004\x006B\x0007\uffbe\x0008\uffbe\x000A" + "\uffbe\x000C\uffbe\x0011\x006A\x0012\uffbe\x0013\uffbe\x0014\uffbe\x0015\uffbe" + "\x0016\uffbe\x0017\uffbe\x0018\uffbe\x0019\uffbe\x001A\uffbe\x001B\uffbe\x001C" + "\uffbe\x0023\uffbe\x0024\uffbe\x0001\x0002\x0000\x002C\x0002\uff8e\x0004\uff8e" + "\x0006\uff8e\x0007\uff8e\x0008\uff8e\x000A\uff8e\x000C\uff8e\x0011\uff8e\x0012" + "\uff8e\x0013\uff8e\x0014\uff8e\x0015\uff8e\x0016\uff8e\x0017\uff8e\x0018\uff8e" + "\x0019\uff8e\x001A\uff8e\x001B\uff8e\x001C\uff8e\x0023\uff8e\x0024\uff8e\x0001" + "\x0002\x0000\x002E\x0002\uff87\x0004\uff87\x0006\uff87\x0007\uff87\x0008\uff87" + "\x0009\uff91\x000A\uff87\x000C\uff87\x0011\uff87\x0012\uff87\x0013\uff87\x0014" + "\uff87\x0015\uff87\x0016\uff87\x0017\uff87\x0018\uff87\x0019\uff87\x001A\uff87" + "\x001B\uff87\x001C\uff87\x0023\uff87\x0024\uff87\x0001\x0002\x0000\x0038\x0005" + "\x0049\x000B\x0043\x000E\x0036\x000F\x0046\x001A\x0019\x001B\x0020\x001E\x001C" + "\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027" + "\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059" + "\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034" + "\x0057\x0001\x0002\x0000\x0038\x0005\x0049\x000B\x0043\x000E\x0036\x000F\x0046" + "\x001A\x0019\x001B\x0020\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022" + "\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E" + "\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031" + "\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0001\x0002\x0000\x002C\x0002\uff87" + "\x0004\uff87\x0006\uff87\x0007\uff87\x0008\uff87\x000A\uff87\x000C\uff87\x0011" + "\uff87\x0012\uff87\x0013\uff87\x0014\uff87\x0015\uff87\x0016\uff87\x0017\uff87" + "\x0018\uff87\x0019\uff87\x001A\uff87\x001B\uff87\x001C\uff87\x0023\uff87\x0024" + "\uff87\x0001\x0002\x0000\x002A\x0002\uffbb\x0004\uffbb\x0007\uffbb\x0008\uffbb" + "\x000A\uffbb\x000C\uffbb\x0011\uffbb\x0012\uffbb\x0013\uffbb\x0014\uffbb\x0015" + "\uffbb\x0016\uffbb\x0017\uffbb\x0018\uffbb\x0019\uffbb\x001A\uffbb\x001B\uffbb" + "\x001C\uffbb\x0023\uffbb\x0024\uffbb\x0001\x0002\x0000\x002A\x0002\uffb6\x0004" + "\uffb6\x0007\uffb6\x0008\uffb6\x000A\uffb6\x000C\uffb6\x0011\uffb6\x0012\uffb6" + "\x0013\uffb6\x0014\uffb6\x0015\uffb6\x0016\uffb6\x0017\uffb6\x0018\uffb6\x0019" + "\uffb6\x001A\uffb6\x001B\uffb6\x001C\uffb6\x0023\uffb6\x0024\uffb6\x0001\x0002" + "\x0000\x0048\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C\x000E" + "\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D\x002F" + "\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026" + "\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063" + "\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033" + "\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x0048\x0004\x0031" + "\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C\x000E\x0036\x000F\x0046\x0011" + "\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D\x002F\x001E\x001C\x001F\x004B" + "\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028" + "\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055" + "\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0035" + "\x005A\x0036\x003A\x0001\x0002\x0000\x0048\x0004\x0031\x0005\x0049\x0009\x0039" + "\x000B\x0043\x000D\x005C\x000E\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A" + "\x0019\x001B\x0020\x001D\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062" + "\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A" + "\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044" + "\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001" + "\x0002\x0000\x0024\x0002\uffc8\x0007\uffc8\x000A\uffc8\x000C\uffc8\x0012\uffc8" + "\x0013\uffc8\x0014\uffc8\x0015\uffc8\x0016\uffc8\x0017\uffc8\x0018\uffc8\x0019" + "\uffc8\x001A\uffc8\x001B\uffc8\x001C\uffc8\x0023\uffc8\x0024\uffc8\x0001\x0002" + "\x0000\x0024\x0002\uffc9\x0007\uffc9\x000A\uffc9\x000C\uffc9\x0012\uffc9\x0013" + "\uffc9\x0014\uffc9\x0015\uffc9\x0016\uffc9\x0017\uffc9\x0018\uffc9\x0019\uffc9" + "\x001A\uffc9\x001B\uffc9\x001C\uffc9\x0023\uffc9\x0024\uffc9\x0001\x0002\x0000" + "\x0024\x0002\uffc7\x0007\uffc7\x000A\uffc7\x000C\uffc7\x0012\uffc7\x0013\uffc7" + "\x0014\uffc7\x0015\uffc7\x0016\uffc7\x0017\uffc7\x0018\uffc7\x0019\uffc7\x001A" + "\uffc7\x001B\uffc7\x001C\uffc7\x0023\uffc7\x0024\uffc7\x0001\x0002\x0000\x002C" + "\x0002\uff90\x0004\uff90\x0006\uff90\x0007\uff90\x0008\uff90\x000A\uff90\x000C" + "\uff90\x0011\uff90\x0012\uff90\x0013\uff90\x0014\uff90\x0015\uff90\x0016\uff90" + "\x0017\uff90\x0018\uff90\x0019\uff90\x001A\uff90\x001B\uff90\x001C\uff90\x0023" + "\uff90\x0024\uff90\x0001\x0002\x0000\x002C\x0002\uff80\x0004\uff80\x0006\uff80" + "\x0007\uff80\x0008\uff80\x000A\uff80\x000C\uff80\x0011\uff80\x0012\uff80\x0013" + "\uff80\x0014\uff80\x0015\uff80\x0016\uff80\x0017\uff80\x0018\uff80\x0019\uff80" + "\x001A\uff80\x001B\uff80\x001C\uff80\x0023\uff80\x0024\uff80\x0001\x0002\x0000" + "\x002C\x0002\uff96\x0004\uff96\x0006\uff96\x0007\uff96\x0008\uff96\x000A\uff96" + "\x000C\uff96\x0011\uff96\x0012\uff96\x0013\uff96\x0014\uff96\x0015\uff96\x0016" + "\uff96\x0017\uff96\x0018\uff96\x0019\uff96\x001A\uff96\x001B\uff96\x001C\uff96" + "\x0023\uff96\x0024\uff96\x0001\x0002\x0000\x002C\x0002\uff7f\x0004\uff7f\x0006" + "\uff7f\x0007\uff7f\x0008\uff7f\x000A\uff7f\x000C\uff7f\x0011\uff7f\x0012\uff7f" + "\x0013\uff7f\x0014\uff7f\x0015\uff7f\x0016\uff7f\x0017\uff7f\x0018\uff7f\x0019" + "\uff7f\x001A\uff7f\x001B\uff7f\x001C\uff7f\x0023\uff7f\x0024\uff7f\x0001\x0002" + "\x0000\x002C\x0002\uffdb\x0004\uffdb\x0006\uffdb\x0007\uffdb\x0008\uffdb\x000A" + "\uffdb\x000C\uffdb\x0011\uffdb\x0012\uffdb\x0013\uffdb\x0014\uffdb\x0015\uffdb" + "\x0016\uffdb\x0017\uffdb\x0018\uffdb\x0019\uffdb\x001A\uffdb\x001B\uffdb\x001C" + "\uffdb\x0023\uffdb\x0024\uffdb\x0001\x0002\x0000\x0038\x0005\x0049\x000B\x0043" + "\x000E\x0036\x000F\x0046\x001A\x0019\x001B\x0020\x001E\x001C\x001F\x004B\x0020" + "\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028\x004D" + "\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055\x002F" + "\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0001\x0002" + "\x0000\x0038\x0005\x0049\x000B\x0043\x000E\x0036\x000F\x0046\x001A\x0019\x001B" + "\x0020\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033" + "\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C" + "\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037" + "\x0033\x0030\x0034\x0057\x0001\x0002\x0000\x002A\x0002\uffc0\x0004\x006B\x0007" + "\uffc0\x0008\uffc0\x000A\uffc0\x000C\uffc0\x0011\x006A\x0012\uffc0\x0013\uffc0" + "\x0014\uffc0\x0015\uffc0\x0016\uffc0\x0017\uffc0\x0018\uffc0\x0019\uffc0\x001A" + "\uffc0\x001B\uffc0\x001C\uffc0\x0023\uffc0\x0024\uffc0\x0001\x0002\x0000\x002A" + "\x0002\uffbf\x0004\x006B\x0007\uffbf\x0008\uffbf\x000A\uffbf\x000C\uffbf\x0011" + "\x006A\x0012\uffbf\x0013\uffbf\x0014\uffbf\x0015\uffbf\x0016\uffbf\x0017\uffbf" + "\x0018\uffbf\x0019\uffbf\x001A\uffbf\x001B\uffbf\x001C\uffbf\x0023\uffbf\x0024" + "\uffbf\x0001\x0002\x0000\x0046\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043" + "\x000D\x005C\x000E\x0036\x000F\x0046\x0011\x0038\x001A\x0019\x001B\x0020\x001D" + "\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033" + "\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C" + "\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037" + "\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x0024\x0002" + "\uffc3\x0007\uffc3\x000A\uffc3\x000C\uffc3\x0012\uffc3\x0013\uffc3\x0014\uffc3" + "\x0015\uffc3\x0016\uffc3\x0017\uffc3\x0018\uffc3\x0019\uffc3\x001A\uffc3\x001B" + "\uffc3\x001C\uffc3\x0023\uffc3\x0024\uffc3\x0001\x0002\x0000\x002A\x0002\uff9d" + "\x0004\uff9d\x0007\uff9d\x0008\uff9d\x000A\uff9d\x000C\uff9d\x0011\uff9d\x0012" + "\uff9d\x0013\uff9d\x0014\uff9d\x0015\uff9d\x0016\uff9d\x0017\uff9d\x0018\uff9d" + "\x0019\uff9d\x001A\uff9d\x001B\uff9d\x001C\uff9d\x0023\uff9d\x0024\uff9d\x0001" + "\x0002\x0000\x004A\x0004\x0031\x0005\x0049\x0009\x0039\x000A\x0082\x000B\x0043" + "\x000D\x005C\x000E\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B" + "\x0020\x001D\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065" + "\x0025\x0033\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B" + "\x003F\x002C\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060" + "\x0032\x0037\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000" + "\x002C\x0002\uff95\x0004\uff95\x0006\uff95\x0007\uff95\x0008\uff95\x000A\uff95" + "\x000C\uff95\x0011\uff95\x0012\uff95\x0013\uff95\x0014\uff95\x0015\uff95\x0016" + "\uff95\x0017\uff95\x0018\uff95\x0019\uff95\x001A\uff95\x001B\uff95\x001C\uff95" + "\x0023\uff95\x0024\uff95\x0001\x0002\x0000\x0006\x000A\uff93\x000C\x0087\x0001" + "\x0002\x0000\x0006\x000A\uff8f\x000C\uff8f\x0001\x0002\x0000\x0004\x000A\x0086" + "\x0001\x0002\x0000\x002C\x0002\uff94\x0004\uff94\x0006\uff94\x0007\uff94\x0008" + "\uff94\x000A\uff94\x000C\uff94\x0011\uff94\x0012\uff94\x0013\uff94\x0014\uff94" + "\x0015\uff94\x0016\uff94\x0017\uff94\x0018\uff94\x0019\uff94\x001A\uff94\x001B" + "\uff94\x001C\uff94\x0023\uff94\x0024\uff94\x0001\x0002\x0000\x0048\x0004\x0031" + "\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C\x000E\x0036\x000F\x0046\x0011" + "\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D\x002F\x001E\x001C\x001F\x004B" + "\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028" + "\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055" + "\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0035" + "\x005A\x0036\x003A\x0001\x0002\x0000\x0004\x000A\uff92\x0001\x0002\x0000\x0048" + "\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C\x000E\x0036\x000F" + "\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D\x002F\x001E\x001C" + "\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027" + "\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059" + "\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034" + "\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x0048\x0004\x0031\x0005\x0049" + "\x0009\x0039\x000B\x0043\x000D\x005C\x000E\x0036\x000F\x0046\x0011\x0038\x0019" + "\x003D\x001A\x0019\x001B\x0020\x001D\x002F\x001E\x001C\x001F\x004B\x0020\x0061" + "\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028\x004D\x0029" + "\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055\x002F\x004E" + "\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0035\x005A\x0036" + "\x003A\x0001\x0002\x0000\x0024\x0002\uffcb\x0007\uffcb\x000A\uffcb\x000C\uffcb" + "\x0012\uffcb\x0013\uffcb\x0014\uffcb\x0015\uffcb\x0016\uffcb\x0017\uffcb\x0018" + "\uffcb\x0019\uffcb\x001A\x0071\x001B\x006F\x001C\x0070\x0023\uffcb\x0024\uffcb" + "\x0001\x0002\x0000\x0024\x0002\uffcc\x0007\uffcc\x000A\uffcc\x000C\uffcc\x0012" + "\uffcc\x0013\uffcc\x0014\uffcc\x0015\uffcc\x0016\uffcc\x0017\uffcc\x0018\uffcc" + "\x0019\uffcc\x001A\x0071\x001B\x006F\x001C\x0070\x0023\uffcc\x0024\uffcc\x0001" + "\x0002\x0000\x002A\x0002\uffb3\x0004\uffb3\x0007\uffb3\x0008\uffb3\x000A\uffb3" + "\x000C\uffb3\x0011\uffb3\x0012\uffb3\x0013\uffb3\x0014\uffb3\x0015\uffb3\x0016" + "\uffb3\x0017\uffb3\x0018\uffb3\x0019\uffb3\x001A\uffb3\x001B\uffb3\x001C\uffb3" + "\x0023\uffb3\x0024\uffb3\x0001\x0002\x0000\x0048\x0004\x0031\x0005\x0049\x0009" + "\x0039\x000B\x0043\x000D\x005C\x000E\x0036\x000F\x0046\x0011\x0038\x0019\x003D" + "\x001A\x0019\x001B\x0020\x001D\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021" + "\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053" + "\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030" + "\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A" + "\x0001\x0002\x0000\x0048\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043\x000D" + "\x005C\x000E\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B\x0020" + "\x001D\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025" + "\x0033\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F" + "\x002C\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032" + "\x0037\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x001A" + "\x0002\uffd3\x0007\uffd3\x000A\uffd3\x000C\uffd3\x0012\uffd3\x0013\uffd3\x0014" + "\x0091\x0015\x0092\x0016\x0093\x0017\x0094\x0023\uffd3\x0024\uffd3\x0001\x0002" + "\x0000\x0048\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C\x000E" + "\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D\x002F" + "\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026" + "\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063" + "\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033" + "\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x0048\x0004\x0031" + "\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C\x000E\x0036\x000F\x0046\x0011" + "\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D\x002F\x001E\x001C\x001F\x004B" + "\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028" + "\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055" + "\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0035" + "\x005A\x0036\x003A\x0001\x0002\x0000\x0048\x0004\x0031\x0005\x0049\x0009\x0039" + "\x000B\x0043\x000D\x005C\x000E\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A" + "\x0019\x001B\x0020\x001D\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062" + "\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A" + "\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044" + "\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001" + "\x0002\x0000\x0048\x0004\x0031\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C" + "\x000E\x0036\x000F\x0046\x0011\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D" + "\x002F\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033" + "\x0026\x0032\x0027\x0035\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C" + "\x0063\x002D\x0059\x002E\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037" + "\x0033\x0030\x0034\x0057\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x001E\x0002" + "\uffce\x0007\uffce\x000A\uffce\x000C\uffce\x0012\uffce\x0013\uffce\x0014\uffce" + "\x0015\uffce\x0016\uffce\x0017\uffce\x0018\x0089\x0019\x008A\x0023\uffce\x0024" + "\uffce\x0001\x0002\x0000\x001E\x0002\uffcf\x0007\uffcf\x000A\uffcf\x000C\uffcf" + "\x0012\uffcf\x0013\uffcf\x0014\uffcf\x0015\uffcf\x0016\uffcf\x0017\uffcf\x0018" + "\x0089\x0019\x008A\x0023\uffcf\x0024\uffcf\x0001\x0002\x0000\x001E\x0002\uffd0" + "\x0007\uffd0\x000A\uffd0\x000C\uffd0\x0012\uffd0\x0013\uffd0\x0014\uffd0\x0015" + "\uffd0\x0016\uffd0\x0017\uffd0\x0018\x0089\x0019\x008A\x0023\uffd0\x0024\uffd0" + "\x0001\x0002\x0000\x001E\x0002\uffd1\x0007\uffd1\x000A\uffd1\x000C\uffd1\x0012" + "\uffd1\x0013\uffd1\x0014\uffd1\x0015\uffd1\x0016\uffd1\x0017\uffd1\x0018\x0089" + "\x0019\x008A\x0023\uffd1\x0024\uffd1\x0001\x0002\x0000\x001A\x0002\uffd4\x0007" + "\uffd4\x000A\uffd4\x000C\uffd4\x0012\uffd4\x0013\uffd4\x0014\x0091\x0015\x0092" + "\x0016\x0093\x0017\x0094\x0023\uffd4\x0024\uffd4\x0001\x0002\x0000\x0048\x0004" + "\x0031\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C\x000E\x0036\x000F\x0046" + "\x0011\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D\x002F\x001E\x001C\x001F" + "\x004B\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035" + "\x0028\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E" + "\x0055\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057" + "\x0035\x005A\x0036\x003A\x0001\x0002\x0000\x000E\x0002\uffd8\x0007\uffd8\x000A" + "\uffd8\x000C\uffd8\x0023\uffd8\x0024\x009C\x0001\x0002\x0000\x0048\x0004\x0031" + "\x0005\x0049\x0009\x0039\x000B\x0043\x000D\x005C\x000E\x0036\x000F\x0046\x0011" + "\x0038\x0019\x003D\x001A\x0019\x001B\x0020\x001D\x002F\x001E\x001C\x001F\x004B" + "\x0020\x0061\x0021\x0062\x0022\x0065\x0025\x0033\x0026\x0032\x0027\x0035\x0028" + "\x004D\x0029\x0053\x002A\x005E\x002B\x003F\x002C\x0063\x002D\x0059\x002E\x0055" + "\x002F\x004E\x0030\x0044\x0031\x0060\x0032\x0037\x0033\x0030\x0034\x0057\x0035" + "\x005A\x0036\x003A\x0001\x0002\x0000\x0012\x0002\uffd6\x0007\uffd6\x000A\uffd6" + "\x000C\uffd6\x0012\x008E\x0013\x008F\x0023\uffd6\x0024\uffd6\x0001\x0002\x0000" + "\x0032\x000B\uffaf\x001A\uffaf\x001B\uffaf\x001E\uffaf\x001F\uffaf\x0020\uffaf" + "\x0021\uffaf\x0022\uffaf\x0025\uffaf\x0026\uffaf\x0027\uffaf\x0028\uffaf\x0029" + "\uffaf\x002A\uffaf\x002B\uffaf\x002C\uffaf\x002D\uffaf\x002E\uffaf\x002F\uffaf" + "\x0030\uffaf\x0031\uffaf\x0032\uffaf\x0033\uffaf\x0034\uffaf\x0001\x0002\x0000" + "\x002C\x0002\uffb1\x0004\uffb1\x0006\x002D\x0007\uffb1\x0008\uffb1\x000A\uffb1" + "\x000C\uffb1\x0011\uffb1\x0012\uffb1\x0013\uffb1\x0014\uffb1\x0015\uffb1\x0016" + "\uffb1\x0017\uffb1\x0018\uffb1\x0019\uffb1\x001A\uffb1\x001B\uffb1\x001C\uffb1" + "\x0023\uffb1\x0024\uffb1\x0001\x0002\x0000\x002A\x0002\uffb2\x0004\uffb2\x0007" + "\uffb2\x0008\uffb2\x000A\uffb2\x000C\uffb2\x0011\uffb2\x0012\uffb2\x0013\uffb2" + "\x0014\uffb2\x0015\uffb2\x0016\uffb2\x0017\uffb2\x0018\uffb2\x0019\uffb2\x001A" + "\uffb2\x001B\uffb2\x001C\uffb2\x0023\uffb2\x0024\uffb2\x0001\x0002\x0000\x0024" + "\x0002\uffc5\x0007\uffc5\x000A\uffc5\x000C\uffc5\x0012\uffc5\x0013\uffc5\x0014" + "\uffc5\x0015\uffc5\x0016\uffc5\x0017\uffc5\x0018\uffc5\x0019\uffc5\x001A\uffc5" + "\x001B\uffc5\x001C\uffc5\x0023\uffc5\x0024\uffc5\x0001\x0002\x0000\x0004\x000A" + "\x00A3\x0001\x0002\x0000\x002C\x0002\uff9b\x0004\uff9b\x0006\uff9b\x0007\uff9b" + "\x0008\uff9b\x000A\uff9b\x000C\uff9b\x0011\uff9b\x0012\uff9b\x0013\uff9b\x0014" + "\uff9b\x0015\uff9b\x0016\uff9b\x0017\uff9b\x0018\uff9b\x0019\uff9b\x001A\uff9b" + "\x001B\uff9b\x001C\uff9b\x0023\uff9b\x0024\uff9b\x0001\x0002\x0000\x002A\x0002" + "\uffb5\x0004\x006B\x0007\uffb5\x0008\uffb5\x000A\uffb5\x000C\uffb5\x0011\x006A" + "\x0012\uffb5\x0013\uffb5\x0014\uffb5\x0015\uffb5\x0016\uffb5\x0017\uffb5\x0018" + "\uffb5\x0019\uffb5\x001A\uffb5\x001B\uffb5\x001C\uffb5\x0023\uffb5\x0024\uffb5" + "\x0001\x0002\x0000\x0004\x001D\x00A6\x0001\x0002\x0000\x0004\x000A\x00A7\x0001" + "\x0002\x0000\x002C\x0002\uff8a\x0004\uff8a\x0006\uff8a\x0007\uff8a\x0008\uff8a" + "\x000A\uff8a\x000C\uff8a\x0011\uff8a\x0012\uff8a\x0013\uff8a\x0014\uff8a\x0015" + "\uff8a\x0016\uff8a\x0017\uff8a\x0018\uff8a\x0019\uff8a\x001A\uff8a\x001B\uff8a" + "\x001C\uff8a\x0023\uff8a\x0024\uff8a\x0001\x0002\x0000\x002A\x0002\uffb8\x0004" + "\x006B\x0007\uffb8\x0008\uffb8\x000A\uffb8\x000C\uffb8\x0011\x006A\x0012\uffb8" + "\x0013\uffb8\x0014\uffb8\x0015\uffb8\x0016\uffb8\x0017\uffb8\x0018\uffb8\x0019" + "\uffb8\x001A\uffb8\x001B\uffb8\x001C\uffb8\x0023\uffb8\x0024\uffb8\x0001\x0002" + "\x0000\x002A\x0002\uffdc\x0004\uffdc\x0007\uffdc\x0008\uffdc\x000A\uffdc\x000C" + "\uffdc\x0011\uffdc\x0012\uffdc\x0013\uffdc\x0014\uffdc\x0015\uffdc\x0016\uffdc" + "\x0017\uffdc\x0018\uffdc\x0019\uffdc\x001A\uffdc\x001B\uffdc\x001C\uffdc\x0023" + "\uffdc\x0024\uffdc\x0001\x0002\x0000\x0032\x000B\uffde\x001A\uffde\x001B\uffde" + "\x001E\uffde\x001F\uffde\x0020\uffde\x0021\uffde\x0022\uffde\x0025\uffde\x0026" + "\uffde\x0027\uffde\x0028\uffde\x0029\uffde\x002A\uffde\x002B\uffde\x002C\uffde" + "\x002D\uffde\x002E\uffde\x002F\uffde\x0030\uffde\x0031\uffde\x0032\uffde\x0033" + "\uffde\x0034\uffde\x0001\x0002\x0000\x0004\x001D\x00AC\x0001\x0002\x0000\x0004" + "\x000C\x00AD\x0001\x0002\x0000\x0004\x001D\x00AE\x0001\x0002\x0000\x0004\x000A" + "\x00AF\x0001\x0002\x0000\x000A\x0002\ufff4\x0004\ufff4\x0008\ufff4\x0011\ufff4" + "\x0001\x0002\x0000\x0004\x001D\x00B1\x0001\x0002\x0000\x0004\x000A\x00B2\x0001" + "\x0002\x0000\x000A\x0002\ufff5\x0004\ufff5\x0008\ufff5\x0011\ufff5\x0001\x0002" + "\x0000\x000A\x0002\uffec\x0004\uffec\x0008\uffec\x0011\uffec\x0001\x0002\x0000" + "\x0032\x000B\uffdf\x001A\uffdf\x001B\uffdf\x001E\uffdf\x001F\uffdf\x0020\uffdf" + "\x0021\uffdf\x0022\uffdf\x0025\uffdf\x0026\uffdf\x0027\uffdf\x0028\uffdf\x0029" + "\uffdf\x002A\uffdf\x002B\uffdf\x002C\uffdf\x002D\uffdf\x002E\uffdf\x002F\uffdf" + "\x0030\uffdf\x0031\uffdf\x0032\uffdf\x0033\uffdf\x0034\uffdf\x0001\x0002\x0000" + "\x0034\x000B\x0017\x000E\x0010\x001A\x0019\x001B\x0020\x001E\x001C\x001F\x004B" + "\x0020\x0061\x0021\x0027\x0022\x0029\x0025\x000D\x0026\x000C\x0027\x000E\x0028" + "\x001E\x0029\x001F\x002A\x0024\x002B\x0015\x002C\x0028\x002D\x0023\x002E\x0021" + "\x002F\x001D\x0030\x0018\x0031\x0025\x0032\x0011\x0033\x000A\x0034\x0022\x0001" + "\x0002\x0000\x0034\x000B\x0017\x000E\x0010\x001A\x0019\x001B\x0020\x001E\x001C" + "\x001F\x004B\x0020\x0061\x0021\x0027\x0022\x0029\x0025\x000D\x0026\x000C\x0027" + "\x000E\x0028\x001E\x0029\x001F\x002A\x0024\x002B\x0015\x002C\x0028\x002D\x0023" + "\x002E\x0021\x002F\x001D\x0030\x0018\x0031\x0025\x0032\x0011\x0033\x000A\x0034" + "\x0022\x0001\x0002\x0000\x0006\x0002\ufff1\x0008\ufff1\x0001\x0002\x0000\x0006" + "\x0002\ufff0\x0008\ufff0\x0001\x0002\x0000\x0006\x0002\ufff7\x0008\ufff7\x0001" + "\x0002\x0000\x000C\x0002\uffe9\x0004\uffe9\x0006\x002D\x0008\uffe9\x0011\uffe9" + "\x0001\x0002\x0000\x000C\x0002\uffeb\x0004\uffeb\x0006\x002D\x0008\uffeb\x0011" + "\uffeb\x0001\x0002\x0000\x000A\x0002\uffea\x0004\uffea\x0008\uffea\x0011\uffea" + "\x0001\x0002\x0000\x000A\x0002\uffe8\x0004\uffe8\x0008\uffe8\x0011\uffe8\x0001" + "\x0002\x0000\x0034\x000B\x0017\x000E\x0010\x001A\x0019\x001B\x0020\x001E\x001C" + "\x001F\x004B\x0020\x0061\x0021\x0027\x0022\x0029\x0025\x000D\x0026\x000C\x0027" + "\x000E\x0028\x001E\x0029\x001F\x002A\x0024\x002B\x0015\x002C\x0028\x002D\x0023" + "\x002E\x0021\x002F\x001D\x0030\x0018\x0031\x0025\x0032\x0011\x0033\x000A\x0034" + "\x0022\x0001\x0002\x0000\x0034\x000B\x0017\x000E\x0010\x001A\x0019\x001B\x0020" + "\x001E\x001C\x001F\x004B\x0020\x0061\x0021\x0027\x0022\x0029\x0025\x000D\x0026" + "\x000C\x0027\x000E\x0028\x001E\x0029\x001F\x002A\x0024\x002B\x0015\x002C\x0028" + "\x002D\x0023\x002E\x0021\x002F\x001D\x0030\x0018\x0031\x0025\x0032\x0011\x0033" + "\x000A\x0034\x0022\x0001\x0002\x0000\x0006\x0002\ufff9\x0008\ufff9\x0001\x0002" + "\x0000\x0006\x0002\ufff8\x0008\ufff8\x0001\x0002\x0000\x0004\x001D\x00C3\x0001" + "\x0002\x0000\x0004\x000A\x00C4\x0001\x0002\x0000\x000C\x0002\ufff3\x0004\ufff3" + "\x0006\ufff3\x0008\ufff3\x0011\ufff3\x0001\x0002\x0000\x0006\x0002\ufffb\x0008" + "\ufffb\x0001\x0002\x0000\x0038\x0004\x000B\x000B\x0017\x000E\x0010\x0011\x0013" + "\x001A\x0019\x001B\x0020\x001E\x001C\x001F\x001B\x0020\x0026\x0021\x0027\x0022" + "\x0029\x0025\x000D\x0026\x000C\x0027\x000E\x0028\x001E\x0029\x001F\x002A\x0024" + "\x002B\x0015\x002C\x0028\x002D\x0023\x002E\x0021\x002F\x001D\x0030\x0018\x0031" + "\x0025\x0032\x0011\x0033\x000A\x0034\x0022\x0001\x0002\x0000\x0004\x0002\ufffd" + "\x0001\x0002\x0000\x0004\x0002\uffff\x0001\x0002\x0000\x0004\x0002\x0001\x0001" + "\x0002"});

	  /// <summary>
	  /// Access to parse-action table. </summary>
	  public virtual short[][] action_table()
	  {
		  return _action_table;
	  }

	  /// <summary>
	  /// <code>reduce_goto</code> table. </summary>
	  protected internal static readonly short[][] _reduce_table = unpackFromStrings(new string[] {"\x0000\x00C7\x0000\x0004\x0003\x0003\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0038\x0004\x00C7\x0006\x0050\x0008\x0057\x0009\x004F\x000A\x0041\x000B\x003D" + "\x000C\x0044\x000D\x0033\x000E\x0049\x000F\x0065\x0010\x004B\x0011\x0055\x0012" + "\x003B\x0013\x0051\x0014\x0063\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C" + "\x0019\x0047\x001A\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A" + "\x0040\x002B\x003F\x0001\x0001\x0000\x0016\x001D\x000E\x001E\x0007\x001F\x0006" + "\x0020\x0019\x0021\x0015\x0022\x0013\x0023\x002A\x0024\x0008\x0027\x0029\x002C" + "\x0011\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0010\x0020\x0019\x0021\x00C4\x0022" + "\x0013\x0023\x002A\x0024\x0008\x0027\x0029\x002C\x0011\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x000A\x0020\x00B9" + "\x0023\x00BA\x0024\x0008\x0027\x0029\x0001\x0001\x0000\x0010\x0020\x0019\x0021" + "\x00B8\x0022\x0013\x0023\x002A\x0024\x0008\x0027\x0029\x002C\x0011\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0006" + "\x0007\x002B\x0025\x00B2\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0006\x0007\x002B\x0025\x002D\x0001\x0001" + "\x0000\x0006\x0007\x002B\x0025\x00A8\x0001\x0001\x0000\x0038\x0004\x005A\x0006" + "\x0050\x0008\x0057\x0009\x004F\x000A\x0041\x000B\x003D\x000C\x0044\x000D\x0033" + "\x000E\x0049\x000F\x0065\x0010\x004B\x0011\x0055\x0012\x003B\x0013\x0051\x0014" + "\x0063\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A" + "\x001B\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0014\x0009\x004F\x0016\x005E\x0017\x00A7\x0018\x005C\x001B\x0046\x001C" + "\x0067\x0027\x006B\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0014\x0009\x004F\x0016\x005E" + "\x0017\x00A3\x0018\x005C\x001B\x0046\x001C\x0067\x0027\x006B\x002A\x0040\x002B" + "\x003F\x0001\x0001\x0000\x0038\x0004\x00A1\x0006\x0050\x0008\x0057\x0009\x004F" + "\x000A\x0041\x000B\x003D\x000C\x0044\x000D\x0033\x000E\x0049\x000F\x0065\x0010" + "\x004B\x0011\x0055\x0012\x003B\x0013\x0051\x0014\x0063\x0015\x0053\x0016\x005E" + "\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A\x001B\x0046\x001C\x0067\x0027" + "\x0068\x0028\x004E\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x002A\x0006\x0050\x0008" + "\x0057\x0009\x004F\x0010\x00A0\x0011\x0055\x0012\x003B\x0013\x0051\x0014\x0063" + "\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A\x001B" + "\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0008\x001B\x009E\x001C" + "\x0067\x0027\x006B\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0006\x0007\x002B\x0025\x008C\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0006\x0007\x002B\x0025\x007F\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0006\x0027\x0074\x0029\x0076\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0010\x0009\x006D\x0016\x005E\x001B\x0046\x001C\x0067\x0027\x006B\x002A\x0040" + "\x002B\x003F\x0001\x0001\x0000\x0010\x0009\x006C\x0016\x005E\x001B\x0046\x001C" + "\x0067\x0027\x006B\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x002A\x0006\x0050\x0008" + "\x0057\x0009\x004F\x0010\x0073\x0011\x0055\x0012\x003B\x0013\x0051\x0014\x0063" + "\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A\x001B" + "\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F\x0001\x0001" + "\x0000\x002A\x0006\x0050\x0008\x0057\x0009\x004F\x0010\x0072\x0011\x0055\x0012" + "\x003B\x0013\x0051\x0014\x0063\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C" + "\x0019\x0047\x001A\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A" + "\x0040\x002B\x003F\x0001\x0001\x0000\x002A\x0006\x0050\x0008\x0057\x0009\x004F" + "\x0010\x0071\x0011\x0055\x0012\x003B\x0013\x0051\x0014\x0063\x0015\x0053\x0016" + "\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A\x001B\x0046\x001C\x0067" + "\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0014\x0009\x004F\x0016\x005E\x0017\x007C\x0018\x005C" + "\x001B\x0046\x001C\x0067\x0027\x006B\x002A\x0040\x002B\x003F\x0001\x0001\x0000" + "\x0014\x0009\x004F\x0016\x005E\x0017\x007B\x0018\x005C\x001B\x0046\x001C\x0067" + "\x0027\x006B\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0028\x0006\x0050\x0008\x0057\x0009\x004F\x0011\x0055" + "\x0012\x003B\x0013\x0051\x0014\x007E\x0015\x0053\x0016\x005E\x0017\x0066\x0018" + "\x005C\x0019\x0047\x001A\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028\x004E" + "\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x003C\x0004\x0083\x0005\x0082\x0006\x0050\x0008\x0057\x0009\x004F" + "\x000A\x0041\x000B\x003D\x000C\x0044\x000D\x0033\x000E\x0049\x000F\x0065\x0010" + "\x004B\x0011\x0055\x0012\x003B\x0013\x0051\x0014\x0063\x0015\x0053\x0016\x005E" + "\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A\x001B\x0046\x001C\x0067\x0026" + "\x0084\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x003C\x0004\x0083\x0005\x0082\x0006\x0050" + "\x0008\x0057\x0009\x004F\x000A\x0041\x000B\x003D\x000C\x0044\x000D\x0033\x000E" + "\x0049\x000F\x0065\x0010\x004B\x0011\x0055\x0012\x003B\x0013\x0051\x0014\x0063" + "\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A\x001B" + "\x0046\x001C\x0067\x0026\x0087\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x002C\x0006\x0050\x0008\x0057\x0009" + "\x004F\x000F\x008B\x0010\x004B\x0011\x0055\x0012\x003B\x0013\x0051\x0014\x0063" + "\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A\x001B" + "\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F\x0001\x0001" + "\x0000\x002C\x0006\x0050\x0008\x0057\x0009\x004F\x000F\x008A\x0010\x004B\x0011" + "\x0055\x0012\x003B\x0013\x0051\x0014\x0063\x0015\x0053\x0016\x005E\x0017\x0066" + "\x0018\x005C\x0019\x0047\x001A\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028" + "\x004E\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0030\x0006\x0050\x0008\x0057\x0009" + "\x004F\x000D\x0098\x000E\x0049\x000F\x0065\x0010\x004B\x0011\x0055\x0012\x003B" + "\x0013\x0051\x0014\x0063\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019" + "\x0047\x001A\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040" + "\x002B\x003F\x0001\x0001\x0000\x0030\x0006\x0050\x0008\x0057\x0009\x004F\x000D" + "\x008F\x000E\x0049\x000F\x0065\x0010\x004B\x0011\x0055\x0012\x003B\x0013\x0051" + "\x0014\x0063\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A" + "\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x002E\x0006\x0050\x0008\x0057\x0009" + "\x004F\x000E\x0097\x000F\x0065\x0010\x004B\x0011\x0055\x0012\x003B\x0013\x0051" + "\x0014\x0063\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A" + "\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F" + "\x0001\x0001\x0000\x002E\x0006\x0050\x0008\x0057\x0009\x004F\x000E\x0096\x000F" + "\x0065\x0010\x004B\x0011\x0055\x0012\x003B\x0013\x0051\x0014\x0063\x0015\x0053" + "\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A\x001B\x0046\x001C" + "\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x002E" + "\x0006\x0050\x0008\x0057\x0009\x004F\x000E\x0095\x000F\x0065\x0010\x004B\x0011" + "\x0055\x0012\x003B\x0013\x0051\x0014\x0063\x0015\x0053\x0016\x005E\x0017\x0066" + "\x0018\x005C\x0019\x0047\x001A\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028" + "\x004E\x002A\x0040\x002B\x003F\x0001\x0001\x0000\x002E\x0006\x0050\x0008\x0057" + "\x0009\x004F\x000E\x0094\x000F\x0065\x0010\x004B\x0011\x0055\x0012\x003B\x0013" + "\x0051\x0014\x0063\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047" + "\x001A\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B" + "\x003F\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0034\x0006" + "\x0050\x0008\x0057\x0009\x004F\x000B\x009A\x000C\x0044\x000D\x0033\x000E\x0049" + "\x000F\x0065\x0010\x004B\x0011\x0055\x0012\x003B\x0013\x0051\x0014\x0063\x0015" + "\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047\x001A\x003A\x001B\x0046" + "\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B\x003F\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0032\x0006\x0050\x0008\x0057\x0009\x004F\x000C\x009C" + "\x000D\x0033\x000E\x0049\x000F\x0065\x0010\x004B\x0011\x0055\x0012\x003B\x0013" + "\x0051\x0014\x0063\x0015\x0053\x0016\x005E\x0017\x0066\x0018\x005C\x0019\x0047" + "\x001A\x003A\x001B\x0046\x001C\x0067\x0027\x0068\x0028\x004E\x002A\x0040\x002B" + "\x003F\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0006" + "\x0007\x002B\x0025\x009F\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000" + "\x0010\x0020\x0019\x0021\x00B7\x0022\x0013\x0023\x002A\x0024\x0008\x0027\x0029" + "\x002C\x0011\x0001\x0001\x0000\x0010\x0020\x0019\x0021\x00B6\x0022\x0013\x0023" + "\x002A\x0024\x0008\x0027\x0029\x002C\x0011\x0001\x0001\x0000\x0002\x0001\x0001" + "\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0006\x0007\x002B\x0025" + "\x00BC\x0001\x0001\x0000\x0006\x0007\x002B\x0025\x00BB\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0010\x0020\x0019\x0021\x00C0\x0022" + "\x0013\x0023\x002A\x0024\x0008\x0027\x0029\x002C\x0011\x0001\x0001\x0000\x0010" + "\x0020\x0019\x0021\x00BF\x0022\x0013\x0023\x002A\x0024\x0008\x0027\x0029\x002C" + "\x0011\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002" + "\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001" + "\x0001\x0000\x0016\x001D\x000E\x001E\x00C6\x001F\x0006\x0020\x0019\x0021\x0015" + "\x0022\x0013\x0023\x002A\x0024\x0008\x0027\x0029\x002C\x0011\x0001\x0001\x0000" + "\x0002\x0001\x0001\x0000\x0002\x0001\x0001\x0000\x0002\x0001\x0001"});

	  /// <summary>
	  /// Access to <code>reduce_goto</code> table. </summary>
	  public virtual short[][] reduce_table()
	  {
		  return _reduce_table;
	  }

	  /// <summary>
	  /// Instance of action encapsulation class. </summary>
	  protected internal CUP_XPathParser_actions action_obj;

	  /// <summary>
	  /// Action encapsulation object initializer. </summary>
	  protected internal virtual void init_actions()
	  {
		  action_obj = new CUP_XPathParser_actions(this);
	  }

	  /// <summary>
	  /// Invoke a user supplied parse action. </summary>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: public java_cup.runtime.Symbol do_action(int act_num, java_cup.runtime.lr_parser parser, java.util.Stack stack, int top) throws java.lang.Exception
	  public virtual java_cup.runtime.Symbol do_action(int act_num, java_cup.runtime.lr_parser parser, System.Collections.Stack stack, int top)
	  {
		/* call code in generated class */
		return action_obj.CUP_XPathParser_do_action(act_num, parser, stack, top);
	  }

	  /// <summary>
	  /// Indicates start state. </summary>
	  public virtual int start_state()
	  {
		  return 0;
	  }
	  /// <summary>
	  /// Indicates start production. </summary>
	  public virtual int start_production()
	  {
		  return 0;
	  }

	  /// <summary>
	  /// <code>EOF</code> Symbol index. </summary>
	  public virtual int EOF_sym()
	  {
		  return 0;
	  }

	  /// <summary>
	  /// <code>error</code> Symbol index. </summary>
	  public virtual int error_sym()
	  {
		  return 1;
	  }



		/// <summary>
		/// Used by function calls with no args.
		/// </summary>
		public static readonly ArrayList EmptyArgs = new ArrayList(0);

		/// <summary>
		/// Reference to non-existing variable.
		/// </summary>
		public const VariableRef DummyVarRef = null;

		/// <summary>
		/// Reference to the Parser class.
		/// </summary>
		private Parser _parser;
		private XSLTC _xsltc;

		/// <summary>
		/// String representation of the expression being parsed.
		/// </summary>
		private string _expression;

		/// <summary>
		/// Line number where this expression/pattern was declared.
		/// </summary>
		private int _lineNumber = 0;

		/// <summary>
		/// Reference to the symbol table.
		/// </summary>
		public SymbolTable _symbolTable;

		public XPathParser(Parser parser)
		{
			_parser = parser;
		_xsltc = parser.XSLTC;
			_symbolTable = parser.SymbolTable;
		}

		public virtual int LineNumber
		{
			get
			{
				return _lineNumber;
			}
		}

		public virtual QName getQNameIgnoreDefaultNs(string name)
		{
			  return _parser.getQNameIgnoreDefaultNs(name);
		}

		public virtual QName getQName(string @namespace, string prefix, string localname)
		{
			return _parser.getQName(@namespace, prefix, localname);
		}

		public virtual bool MultiDocument
		{
			set
			{
				  _xsltc.MultiDocument = value;
			}
		}

		public virtual bool CallsNodeset
		{
			set
			{
				  _xsltc.CallsNodeset = value;
			}
		}

		public virtual bool HasIdCall
		{
			set
			{
				  _xsltc.HasIdCall = value;
			}
		}


		/// <summary>
		/// This method is similar to findNodeType(int, Object) except that it
		/// creates a StepPattern instead of just returning a node type. It also 
		/// differs in the way it handles "{uri}:*" and "{uri}:@*". The last two 
		/// patterns are expanded as "*[namespace-uri() = 'uri']" and 
		/// "@*[namespace-uri() = 'uri']", respectively. This expansion considerably 
		/// simplifies the grouping of patterns in the Mode class. For this
		/// expansion to be correct, the priority of the pattern/template must be
		/// set to -0.25 (when no other predicates are present).
		/// </summary>
		public virtual StepPattern createStepPattern(int axis, object test, ArrayList predicates)
		{
		int nodeType;

		if (test == null)
		{ // "*"
			nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE : (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;

			return new StepPattern(axis, nodeType, predicates);
		}
			else if (test is Integer)
			{
			nodeType = ((int?) test).Value;

			return new StepPattern(axis, nodeType, predicates);
			}
			else
			{
			QName name = (QName)test;
			bool setPriority = false;

			if (axis == Axis.NAMESPACE)
			{
			nodeType = (name.ToString().Equals("*")) ? -1 : _xsltc.registerNamespacePrefix(name);
			}
			else
			{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String uri = name.getNamespace();
			string uri = name.Namespace;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String local = name.getLocalPart();
			string local = name.LocalPart;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final QName namespace_uri = _parser.getQNameIgnoreDefaultNs("namespace-uri");
			QName namespace_uri = _parser.getQNameIgnoreDefaultNs("namespace-uri");

			// Expand {uri}:* to *[namespace-uri() = 'uri'] - same for @*
			if (!string.ReferenceEquals(uri, null) && (local.Equals("*") || local.Equals("@*")))
			{
				if (predicates == null)
				{
				predicates = new ArrayList(2);
				}

				// Priority is set by hand if no other predicates exist
				setPriority = (predicates.Count == 0);

				predicates.Add(new Predicate(new EqualityExpr(Operators.EQ, new NamespaceUriCall(namespace_uri), new LiteralExpr(uri))));
			}

			if (local.Equals("*"))
			{
				nodeType = (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE : NodeTest.ELEMENT;
			}
			else if (local.Equals("@*"))
			{
				nodeType = NodeTest.ATTRIBUTE;
			}
			else
			{
				nodeType = (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name) : _xsltc.registerElement(name);
			}
			}

//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final StepPattern result = new StepPattern(axis, nodeType, predicates);
			StepPattern result = new StepPattern(axis, nodeType, predicates);

			// Set priority for case prefix:* and prefix:@* (no predicates)
			if (setPriority)
			{
			result.Priority = -0.25;
			}

			return result;
			}
		}

		public virtual int findNodeType(int axis, object test)
		{
		if (test == null)
		{ // *
			return (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE : (axis == Axis.NAMESPACE) ? -1 : NodeTest.ELEMENT;
		}
			else if (test is Integer)
			{
				return ((int?)test).Value;
			}
			else
			{
			QName name = (QName)test;

			if (axis == Axis.NAMESPACE)
			{
			return (name.ToString().Equals("*")) ? -1 : _xsltc.registerNamespacePrefix(name);
			}

			if (string.ReferenceEquals(name.Namespace, null))
			{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String local = name.getLocalPart();
			string local = name.LocalPart;

			if (local.Equals("*"))
			{
				return (axis == Axis.ATTRIBUTE) ? NodeTest.ATTRIBUTE : NodeTest.ELEMENT;
			}
			else if (local.Equals("@*"))
			{
				return NodeTest.ATTRIBUTE;
			}
			}

			return (axis == Axis.ATTRIBUTE) ? _xsltc.registerAttribute(name) : _xsltc.registerElement(name);
			}
		}

		/// <summary>
		/// Parse the expression passed to the current scanner. If this
		/// expression contains references to local variables and it will be 
		/// compiled in an external module (not in the main class) request 
		/// the current template to create a new variable stack frame.
		/// </summary>
		/// <param name="lineNumber"> Line where the current expression is defined. </param>
		/// <param name="external">   Set to <tt>true</tt> if this expression is
		///                   compiled in a separate module.
		///  </param>
//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: public Symbol parse(String expression, int lineNumber) throws Exception
		public virtual Symbol parse(string expression, int lineNumber)
		{
			try
			{
			_expression = expression;
			_lineNumber = lineNumber;
			return base.parse();
			}
			catch (IllegalCharException e)
			{
				ErrorMsg err = new ErrorMsg(ErrorMsg.ILLEGAL_CHAR_ERR, lineNumber, e.Message);
				_parser.reportError(Constants.FATAL, err);
			}
			return null;
		}

		/// <summary>
		/// Lookup a variable or parameter in the symbol table given its name. 
		/// </summary>
		/// <param name="name"> Name of the symbol being looked up. </param>
		internal SyntaxTreeNode lookupName(QName name)
		{
			// Is it a local var or param ?
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final SyntaxTreeNode result = _parser.lookupVariable(name);
			SyntaxTreeNode result = _parser.lookupVariable(name);
		if (result != null)
		{
				return (result);
		}
			else
			{
			return (_symbolTable.lookupName(name));
			}
		}

		public void addError(ErrorMsg error)
		{
		_parser.reportError(Constants.ERROR, error);
		}

		public virtual void report_error(string message, object info)
		{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final org.apache.xalan.xsltc.compiler.util.ErrorMsg err = new org.apache.xalan.xsltc.compiler.util.ErrorMsg(org.apache.xalan.xsltc.compiler.util.ErrorMsg.SYNTAX_ERR, _lineNumber, _expression);
		ErrorMsg err = new ErrorMsg(ErrorMsg.SYNTAX_ERR, _lineNumber, _expression);
		_parser.reportError(Constants.FATAL, err);
		}

		public virtual void report_fatal_error(string message, object info)
		{
			// empty
		}

		public virtual RelativeLocationPath insertStep(Step step, RelativeLocationPath rlp)
		{
		if (rlp is Step)
		{
			return new ParentLocationPath(step, (Step) rlp);
		}
		else if (rlp is ParentLocationPath)
		{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final ParentLocationPath plp = (ParentLocationPath) rlp;
			ParentLocationPath plp = (ParentLocationPath) rlp;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final RelativeLocationPath newrlp = insertStep(step, plp.getPath());
			RelativeLocationPath newrlp = insertStep(step, plp.Path);
			return new ParentLocationPath(newrlp, plp.Step);
		}
		else
		{
			addError(new ErrorMsg(ErrorMsg.INTERNAL_ERR, "XPathParser.insertStep"));
			return rlp;
		}
		}

		/// <summary>
		/// Returns true if the axis applies to elements only. The axes
		/// child, attribute, namespace, descendant result in non-empty
		/// nodesets only if the context node is of type element.
		/// </summary>
		public virtual bool isElementAxis(int axis)
		{
		return (axis == Axis.CHILD || axis == Axis.ATTRIBUTE || axis == Axis.NAMESPACE || axis == Axis.DESCENDANT);
		}

	}

	/// <summary>
	/// Cup generated class to encapsulate user supplied action code. </summary>
	internal class CUP_XPathParser_actions
	{
	  private readonly XPathParser parser;

	  /// <summary>
	  /// Constructor </summary>
	  internal CUP_XPathParser_actions(XPathParser parser)
	  {
		this.parser = parser;
	  }

		/// <summary>
		/// Method with the actual generated action code. </summary>
		//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
		//ORIGINAL LINE: public final java_cup.runtime.Symbol CUP_XPathParser_do_action(int CUP_XPathParser_act_num, java_cup.runtime.lr_parser CUP_XPathParser_parser, java.util.Stack CUP_XPathParser_stack, int CUP_XPathParser_top) throws java.lang.Exception
		public java_cup.runtime.Symbol CUP_XPathParser_do_action(int CUP_XPathParser_act_num, java_cup.runtime.lr_parser CUP_XPathParser_parser, System.Collections.Stack CUP_XPathParser_stack, int CUP_XPathParser_top)
	  {
		  /* Symbol object for return from actions */
		  java_cup.runtime.Symbol CUP_XPathParser_result;

		  /* select the action based on the action number */
		  switch (CUP_XPathParser_act_num)
		  {
			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 140: // QName ::= ID
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("id");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 139: // QName ::= SELF
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("self");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 138: // QName ::= PRECEDINGSIBLING
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("preceding-sibling");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 137: // QName ::= PRECEDING
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("preceding");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 136: // QName ::= PARENT
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("parent");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 135: // QName ::= NAMESPACE
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("namespace");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 134: // QName ::= FOLLOWINGSIBLING
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("following-sibling");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 133: // QName ::= FOLLOWING
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("following");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 132: // QName ::= DESCENDANTORSELF
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("decendant-or-self");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 131: // QName ::= DESCENDANT
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("decendant");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 130: // QName ::= CHILD
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("child");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 129: // QName ::= ATTRIBUTE
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("attribute");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 128: // QName ::= ANCESTORORSELF
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("ancestor-or-self");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 127: // QName ::= ANCESTOR
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("child");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 126: // QName ::= KEY
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("key");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 125: // QName ::= MOD
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("mod");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 124: // QName ::= DIV
			  {
				  QName RESULT = null;
			 RESULT = parser.getQNameIgnoreDefaultNs("div");
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 123: // QName ::= QNAME
			  {
				  QName RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int qnameleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int qnameright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			string qname = (string)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = parser.getQNameIgnoreDefaultNs(qname);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(37, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 122: // NameTest ::= QName
			  {
				  object RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int qnleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int qnright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			QName qn = (QName)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = qn;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(26, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 121: // NameTest ::= STAR
			  {
				  object RESULT = null;
			 RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(26, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 120: // NodeTest ::= PI
			  {
				  object RESULT = null;
			 RESULT = new int?(NodeTest.PI);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(25, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 119: // NodeTest ::= PIPARAM LPAREN Literal RPAREN
			  {
				  object RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			string l = (string)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;

			   QName name = parser.getQNameIgnoreDefaultNs("name");
			   Expression exp = new EqualityExpr(Operators.EQ, new NameCall(name), new LiteralExpr(l));
			   ArrayList predicates = new ArrayList();
			   predicates.Add(new Predicate(exp));
			   RESULT = new Step(Axis.CHILD, NodeTest.PI, predicates);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(25, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 118: // NodeTest ::= COMMENT
			  {
				  object RESULT = null;
			 RESULT = new int?(NodeTest.COMMENT);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(25, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 117: // NodeTest ::= TEXT
			  {
				  object RESULT = null;
			 RESULT = new int?(NodeTest.TEXT);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(25, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 116: // NodeTest ::= NODE
			  {
				  object RESULT = null;
			 RESULT = new int?(NodeTest.ANODE);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(25, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 115: // NodeTest ::= NameTest
			  {
				  object RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object nt = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = nt;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(25, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 114: // Argument ::= Expr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int exleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int exright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ex = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = ex;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(3, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 113: // VariableName ::= QName
			  {
				  QName RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int vnameleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int vnameright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			QName vname = (QName)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			RESULT = vname;

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(39, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 112: // FunctionName ::= QName
			  {
				  QName RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fnameleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fnameright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			QName fname = (QName)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			RESULT = fname;

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(38, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 111: // NonemptyArgumentList ::= Argument COMMA NonemptyArgumentList
			  {
				  ArrayList RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int argleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int argright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression arg = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int arglleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int arglright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList argl = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 argl.Insert(0, arg);
			 RESULT = argl;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(36, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 110: // NonemptyArgumentList ::= Argument
			  {
				  ArrayList RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int argleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int argright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression arg = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

				ArrayList temp = new ArrayList();
				temp.Add(arg);
				RESULT = temp;

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(36, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 109: // FunctionCall ::= FunctionName LPAREN NonemptyArgumentList RPAREN
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fnameleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fnameright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			QName fname = (QName)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int arglleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int arglright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList argl = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;

			  if (parser.getQNameIgnoreDefaultNs("concat").Equals(fname))
			  {
				RESULT = new ConcatCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("number").Equals(fname))
			  {
				RESULT = new NumberCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("document").Equals(fname))
			  {
			parser.MultiDocument = true;
				RESULT = new DocumentCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("string").Equals(fname))
			  {
				RESULT = new StringCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("boolean").Equals(fname))
			  {
				RESULT = new BooleanCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("name").Equals(fname))
			  {
				RESULT = new NameCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("generate-id").Equals(fname))
			  {
				RESULT = new GenerateIdCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("not").Equals(fname))
			  {
				RESULT = new NotCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("format-number").Equals(fname))
			  {
				RESULT = new FormatNumberCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("unparsed-entity-uri").Equals(fname))
			  {
				RESULT = new UnparsedEntityUriCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("key").Equals(fname))
			  {
				RESULT = new KeyCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("id").Equals(fname))
			  {
				RESULT = new KeyCall(fname, argl);
				parser.HasIdCall = true;
			  }
			  else if (parser.getQNameIgnoreDefaultNs("ceiling").Equals(fname))
			  {
				RESULT = new CeilingCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("round").Equals(fname))
			  {
				RESULT = new RoundCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("floor").Equals(fname))
			  {
				RESULT = new FloorCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("contains").Equals(fname))
			  {
				RESULT = new ContainsCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("string-length").Equals(fname))
			  {
				RESULT = new StringLengthCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("starts-with").Equals(fname))
			  {
				RESULT = new StartsWithCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("function-available").Equals(fname))
			  {
				RESULT = new FunctionAvailableCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("element-available").Equals(fname))
			  {
				RESULT = new ElementAvailableCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("local-name").Equals(fname))
			  {
				RESULT = new LocalNameCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("lang").Equals(fname))
			  {
				RESULT = new LangCall(fname, argl);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("namespace-uri").Equals(fname))
			  {
				RESULT = new NamespaceUriCall(fname, argl);
			  }
			  else if (parser.getQName(Constants.TRANSLET_URI, "xsltc", "cast").Equals(fname))
			  {
				RESULT = new CastCall(fname, argl);
			  }
		  // Special case for extension function nodeset()
			  else if (fname.LocalPart.Equals("nodeset") || fname.LocalPart.Equals("node-set"))
			  {
			parser.CallsNodeset = true; // implies MultiDOM
				RESULT = new FunctionCall(fname, argl);
			  }
			  else
			  {
				RESULT = new FunctionCall(fname, argl);
			  }

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(16, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 108: // FunctionCall ::= FunctionName LPAREN RPAREN
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fnameleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fnameright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			QName fname = (QName)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;


			  if (parser.getQNameIgnoreDefaultNs("current").Equals(fname))
			  {
				RESULT = new CurrentCall(fname);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("number").Equals(fname))
			  {
				RESULT = new NumberCall(fname, org.apache.xalan.xsltc.compiler.XPathParser.EmptyArgs);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("string").Equals(fname))
			  {
				RESULT = new StringCall(fname, org.apache.xalan.xsltc.compiler.XPathParser.EmptyArgs);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("concat").Equals(fname))
			  {
				RESULT = new ConcatCall(fname, org.apache.xalan.xsltc.compiler.XPathParser.EmptyArgs);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("true").Equals(fname))
			  {
				RESULT = new BooleanExpr(true);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("false").Equals(fname))
			  {
				RESULT = new BooleanExpr(false);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("name").Equals(fname))
			  {
				RESULT = new NameCall(fname);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("generate-id").Equals(fname))
			  {
				RESULT = new GenerateIdCall(fname, org.apache.xalan.xsltc.compiler.XPathParser.EmptyArgs);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("string-length").Equals(fname))
			  {
				RESULT = new StringLengthCall(fname, org.apache.xalan.xsltc.compiler.XPathParser.EmptyArgs);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("position").Equals(fname))
			  {
				RESULT = new PositionCall(fname);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("last").Equals(fname))
			  {
				RESULT = new LastCall(fname);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("local-name").Equals(fname))
			  {
				RESULT = new LocalNameCall(fname);
			  }
			  else if (parser.getQNameIgnoreDefaultNs("namespace-uri").Equals(fname))
			  {
				RESULT = new NamespaceUriCall(fname);
			  }
			  else
			  {
				RESULT = new FunctionCall(fname, org.apache.xalan.xsltc.compiler.XPathParser.EmptyArgs);
			  }

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(16, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 107: // VariableReference ::= DOLLAR VariableName
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int varNameleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int varNameright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			QName varName = (QName)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

				// An empty qname prefix for a variable or parameter reference
				// should map to the null namespace and not the default URI.
				SyntaxTreeNode node = parser.lookupName(varName);

				if (node != null)
				{
					if (node is Variable)
					{
						RESULT = new VariableRef((Variable)node);
					}
					else if (node is Param)
					{
						RESULT = new ParameterRef((Param)node);
					}
					else
					{
						RESULT = new UnresolvedRef(varName);
					}
				}

				if (node == null)
				{
					RESULT = new UnresolvedRef(varName);
				}

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(15, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 106: // PrimaryExpr ::= FunctionCall
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fcleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fcright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression fc = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = fc;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(17, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 105: // PrimaryExpr ::= REAL
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int numleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int numright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			double? num = (double?)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new RealExpr(num.Value);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(17, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 104: // PrimaryExpr ::= INT
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int numleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int numright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			long? num = (long?)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

		   long value = num.Value;
		   if (value < int.MinValue || value > int.MaxValue)
		   {
			RESULT = new RealExpr(value);
		   }
		   else
		   {
				   if (num.Value == -0)
				   {
					   RESULT = new RealExpr(num.Value);
				   }
				   else if ((int)num.Value == 0)
				   {
					   RESULT = new IntExpr((int)num.Value);
				   }
				   else if (num.Value == 0.0)
				   {
					   RESULT = new RealExpr(num.Value);
				   }
				   else
				   {
					   RESULT = new IntExpr((int)num.Value);
				   }
		   }

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(17, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 103: // PrimaryExpr ::= Literal
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int stringleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int stringright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			string @string = (string)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

		/*
		* If the string appears to have the syntax of a QName, store 
		* namespace info in the literal expression. This is used for
		* element-available and function-available functions, among
		* others. Also, the default namespace must be ignored.
		*/
		string @namespace = null;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final int index = string.lastIndexOf(':');
		int index = @string.LastIndexOf(':');

		if (index > 0)
		{
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final String prefix = string.substring(0, index);
			string prefix = @string.Substring(0, index);
			@namespace = parser._symbolTable.lookupNamespace(prefix);
		}
		RESULT = (string.ReferenceEquals(@namespace, null)) ? new LiteralExpr(@string) : new LiteralExpr(@string, @namespace);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(17, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 102: // PrimaryExpr ::= LPAREN Expr RPAREN
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int exleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int exright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ex = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
			 RESULT = ex;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(17, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 101: // PrimaryExpr ::= VariableReference
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int vrleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int vrright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression vr = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = vr;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(17, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 100: // FilterExpr ::= PrimaryExpr Predicates
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int primaryleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int primaryright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression primary = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList pp = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new FilterExpr(primary, pp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(6, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 99: // FilterExpr ::= PrimaryExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int primaryleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int primaryright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression primary = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = primary;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(6, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 98: // AbbreviatedStep ::= DDOT
			  {
				  Expression RESULT = null;
			 RESULT = new Step(Axis.PARENT, NodeTest.ANODE, null);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(20, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 97: // AbbreviatedStep ::= DOT
			  {
				  Expression RESULT = null;
			 RESULT = new Step(Axis.SELF, NodeTest.ANODE, null);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(20, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 96: // AxisName ::= SELF
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.SELF);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 95: // AxisName ::= PRECEDINGSIBLING
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.PRECEDINGSIBLING);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 94: // AxisName ::= PRECEDING
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.PRECEDING);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 93: // AxisName ::= PARENT
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.PARENT);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 92: // AxisName ::= NAMESPACE
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.NAMESPACE);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 91: // AxisName ::= FOLLOWINGSIBLING
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.FOLLOWINGSIBLING);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 90: // AxisName ::= FOLLOWING
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.FOLLOWING);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 89: // AxisName ::= DESCENDANTORSELF
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.DESCENDANTORSELF);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 88: // AxisName ::= DESCENDANT
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.DESCENDANT);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 87: // AxisName ::= CHILD
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.CHILD);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 86: // AxisName ::= ATTRIBUTE
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.ATTRIBUTE);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 85: // AxisName ::= ANCESTORORSELF
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.ANCESTORORSELF);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 84: // AxisName ::= ANCESTOR
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.ANCESTOR);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(40, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 83: // AxisSpecifier ::= ATSIGN
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.ATTRIBUTE);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(41, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 82: // AxisSpecifier ::= AxisName DCOLON
			  {
				  int? RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int anleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int anright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int? an = (int?)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
			 RESULT = an;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(41, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 81: // Step ::= AbbreviatedStep
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int abbrevleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int abbrevright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression abbrev = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = abbrev;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(7, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 80: // Step ::= AxisSpecifier NodeTest
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int? axis = (int?)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntestleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntestright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object ntest = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new Step(axis.Value, parser.findNodeType(axis.Value, ntest), null);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(7, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 79: // Step ::= AxisSpecifier NodeTest Predicates
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int? axis = (int?)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntestleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntestright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object ntest = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList pp = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new Step(axis.Value, parser.findNodeType(axis.Value, ntest), pp);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(7, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 78: // Step ::= NodeTest Predicates
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntestleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntestright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object ntest = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList pp = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

				if (ntest is Step)
				{
					Step step = (Step)ntest;
					step.addPredicates(pp);
					RESULT = (Step)ntest;
				}
				else
				{
					RESULT = new Step(Axis.CHILD, parser.findNodeType(Axis.CHILD, ntest), pp);
				}

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(7, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 77: // Step ::= NodeTest
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntestleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntestright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object ntest = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

				if (ntest is Step)
				{
					RESULT = (Step)ntest;
				}
				else
				{
			RESULT = new Step(Axis.CHILD, parser.findNodeType(Axis.CHILD, ntest), null);
				}

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(7, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 76: // AbbreviatedAbsoluteLocationPath ::= DSLASH RelativeLocationPath
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression rlp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			   // 
		   // Expand '//' into '/descendant-or-self::node()/' or
		   // into /descendant-or-self::*/
		   //
		   int nodeType = DOM.NO_TYPE;
		   if (rlp is Step && parser.isElementAxis(((Step) rlp).Axis))
		   {
			   nodeType = DTM.ELEMENT_NODE;
		   }
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final Step step = new Step(org.apache.xml.dtm.Axis.DESCENDANTORSELF, nodeType, null);
		   Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
		   RESULT = new AbsoluteLocationPath(parser.insertStep(step, (RelativeLocationPath) rlp));

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(24, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 75: // AbbreviatedRelativeLocationPath ::= RelativeLocationPath DSLASH Step
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression rlp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int stepleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int stepright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression step = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final Step right = (Step)step;
		   Step right = (Step)step;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final int axis = right.getAxis();
			   int axis = right.Axis;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final int type = right.getNodeType();
			   int type = right.NodeType;
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final java.util.Vector predicates = right.getPredicates();
			   ArrayList predicates = right.Predicates;

			   if ((axis == Axis.CHILD) && (type != NodeTest.ATTRIBUTE))
			   {
				   // Compress './/child:E' into 'descendant::E' - if possible
				   if (predicates == null)
				   {
					   right.Axis = Axis.DESCENDANT;
					   if (rlp is Step && ((Step)rlp).AbbreviatedDot)
					   {
					   RESULT = right;
					   }
					   else
					   {
						   // Expand 'rlp//child::E' into 'rlp/descendant::E'
						   RelativeLocationPath left = (RelativeLocationPath)rlp;
					   RESULT = new ParentLocationPath(left, right);
					   }
				   }
				   else
				   {
					   // Expand './/step' -> 'descendant-or-self::*/step'
					   if (rlp is Step && ((Step)rlp).AbbreviatedDot)
					   {
						   Step left = new Step(Axis.DESCENDANTORSELF, DTM.ELEMENT_NODE, null);
						   RESULT = new ParentLocationPath(left, right);
					   }
					   else
					   {
						   // Expand 'rlp//step' -> 'rlp/descendant-or-self::*/step'
						   RelativeLocationPath left = (RelativeLocationPath)rlp;
						   Step mid = new Step(Axis.DESCENDANTORSELF, DTM.ELEMENT_NODE, null);
						   ParentLocationPath ppl = new ParentLocationPath(mid, right);
						   RESULT = new ParentLocationPath(left, ppl);
					   }
				   }
			   }
			   else if ((axis == Axis.ATTRIBUTE) || (type == NodeTest.ATTRIBUTE))
			   {
				   // Expand 'rlp//step' -> 'rlp/descendant-or-self::*/step'
				   RelativeLocationPath left = (RelativeLocationPath)rlp;
				   Step middle = new Step(Axis.DESCENDANTORSELF, DTM.ELEMENT_NODE, null);
				   ParentLocationPath ppl = new ParentLocationPath(middle, right);
				   RESULT = new ParentLocationPath(left, ppl);
			   }
		   else
		   {
			   // Expand 'rlp//step' -> 'rlp/descendant-or-self::node()/step'
				   RelativeLocationPath left = (RelativeLocationPath)rlp;
			   Step middle = new Step(Axis.DESCENDANTORSELF, DOM.NO_TYPE, null);
				   ParentLocationPath ppl = new ParentLocationPath(middle, right);
			   RESULT = new ParentLocationPath(left, ppl);
		   }

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(22, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 74: // AbsoluteLocationPath ::= AbbreviatedAbsoluteLocationPath
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aalpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aalpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression aalp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = aalp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(23, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 73: // AbsoluteLocationPath ::= SLASH RelativeLocationPath
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression rlp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new AbsoluteLocationPath(rlp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(23, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 72: // AbsoluteLocationPath ::= SLASH
			  {
				  Expression RESULT = null;
			 RESULT = new AbsoluteLocationPath();
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(23, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 71: // RelativeLocationPath ::= AbbreviatedRelativeLocationPath
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int arlpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int arlpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression arlp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = arlp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(21, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 70: // RelativeLocationPath ::= RelativeLocationPath SLASH Step
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression rlp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int stepleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int stepright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression step = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			if (rlp is Step && ((Step) rlp).AbbreviatedDot)
			{
				  RESULT = step; // Remove './' from the middle
			}
			else if (((Step) step).AbbreviatedDot)
			{
				  RESULT = rlp; // Remove '/.' from the end
			}
			else
			{
				 RESULT = new ParentLocationPath((RelativeLocationPath) rlp, step);
			}

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(21, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 69: // RelativeLocationPath ::= Step
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int stepleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int stepright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression step = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = step;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(21, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 68: // LocationPath ::= AbsoluteLocationPath
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int alpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int alpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression alp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = alp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(4, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 67: // LocationPath ::= RelativeLocationPath
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression rlp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = rlp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(4, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 66: // PathExpr ::= FilterExpr DSLASH RelativeLocationPath
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fexpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fexpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression fexp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression rlp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			   // 
		   // Expand '//' into '/descendant-or-self::node()/' or
		   // into /descendant-or-self::*/
		   //
		   int nodeType = DOM.NO_TYPE;
		   if (rlp is Step && parser.isElementAxis(((Step) rlp).Axis))
		   {
			   nodeType = DTM.ELEMENT_NODE;
		   }
//JAVA TO C# CONVERTER WARNING: The original Java variable was marked 'final':
//ORIGINAL LINE: final Step step = new Step(org.apache.xml.dtm.Axis.DESCENDANTORSELF, nodeType, null);
			   Step step = new Step(Axis.DESCENDANTORSELF, nodeType, null);
			   FilterParentPath fpp = new FilterParentPath(fexp, step);
			   fpp = new FilterParentPath(fpp, rlp);
			   if (fexp is KeyCall == false)
			   {
				   fpp.setDescendantAxis();
			   }
			   RESULT = fpp;

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(19, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 65: // PathExpr ::= FilterExpr SLASH RelativeLocationPath
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fexpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fexpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression fexp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rlpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression rlp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new FilterParentPath(fexp, rlp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(19, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 64: // PathExpr ::= FilterExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fexpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int fexpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression fexp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = fexp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(19, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 63: // PathExpr ::= LocationPath
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression lp = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = lp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(19, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 62: // UnionExpr ::= PathExpr VBAR UnionExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int peleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int peright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression pe = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int restleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int restright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression rest = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new UnionPathExpr(pe, rest);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(18, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 61: // UnionExpr ::= PathExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int peleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int peright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression pe = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = pe;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(18, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 60: // UnaryExpr ::= MINUS UnaryExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ue = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new UnaryOpExpr(ue);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(14, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 59: // UnaryExpr ::= UnionExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ue = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = ue;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(14, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 58: // MultiplicativeExpr ::= MultiplicativeExpr MOD UnaryExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression me = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ue = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new BinOpExpr(BinOpExpr.MOD, me, ue);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(13, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 57: // MultiplicativeExpr ::= MultiplicativeExpr DIV UnaryExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression me = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ue = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new BinOpExpr(BinOpExpr.DIV, me, ue);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(13, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 56: // MultiplicativeExpr ::= MultiplicativeExpr MULT UnaryExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression me = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ue = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new BinOpExpr(BinOpExpr.TIMES, me, ue);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(13, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 55: // MultiplicativeExpr ::= UnaryExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ueright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ue = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = ue;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(13, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 54: // AdditiveExpr ::= AdditiveExpr MINUS MultiplicativeExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression me = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new BinOpExpr(BinOpExpr.MINUS, ae, me);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(12, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 53: // AdditiveExpr ::= AdditiveExpr PLUS MultiplicativeExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression me = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new BinOpExpr(BinOpExpr.PLUS, ae, me);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(12, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 52: // AdditiveExpr ::= MultiplicativeExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int meright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression me = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = me;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(12, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 51: // RelationalExpr ::= RelationalExpr GE AdditiveExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int releft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int reright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression re = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new RelationalExpr(Operators.GE, re, ae);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(11, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 50: // RelationalExpr ::= RelationalExpr LE AdditiveExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int releft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int reright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression re = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new RelationalExpr(Operators.LE, re, ae);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(11, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 49: // RelationalExpr ::= RelationalExpr GT AdditiveExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int releft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int reright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression re = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new RelationalExpr(Operators.GT, re, ae);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(11, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 48: // RelationalExpr ::= RelationalExpr LT AdditiveExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int releft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int reright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression re = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new RelationalExpr(Operators.LT, re, ae);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(11, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 47: // RelationalExpr ::= AdditiveExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = ae;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(11, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 46: // EqualityExpr ::= EqualityExpr NE RelationalExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ee = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int releft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int reright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression re = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new EqualityExpr(Operators.NE, ee, re);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(10, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 45: // EqualityExpr ::= EqualityExpr EQ RelationalExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ee = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int releft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int reright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression re = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new EqualityExpr(Operators.EQ, ee, re);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(10, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 44: // EqualityExpr ::= RelationalExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int releft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int reright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression re = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = re;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(10, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 43: // AndExpr ::= AndExpr AND EqualityExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ee = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new LogicalExpr(LogicalExpr.AND, ae, ee);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(9, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 42: // AndExpr ::= EqualityExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression e = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = e;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(9, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 41: // OrExpr ::= OrExpr OR AndExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int oeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int oeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression oe = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new LogicalExpr(LogicalExpr.OR, oe, ae);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(8, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 40: // OrExpr ::= AndExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int aeright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ae = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = ae;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(8, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 39: // Expr ::= OrExpr
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int exleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int exright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression ex = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = ex;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(2, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 38: // Predicate ::= LBRACK Expr RBRACK
			  {
				  Expression RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int eright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression e = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;

			RESULT = new Predicate(e);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(5, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 37: // Predicates ::= Predicate Predicates
			  {
				  ArrayList RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression p = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList pp = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 pp.Insert(0, p);
			 RESULT = pp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(35, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 36: // Predicates ::= Predicate
			  {
				  ArrayList RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression p = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			ArrayList temp = new ArrayList();
			temp.Add(p);
			RESULT = temp;

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(35, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 35: // ChildOrAttributeAxisSpecifier ::= ATTRIBUTE DCOLON
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.ATTRIBUTE);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(42, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 34: // ChildOrAttributeAxisSpecifier ::= CHILD DCOLON
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.CHILD);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(42, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 33: // ChildOrAttributeAxisSpecifier ::= ATSIGN
			  {
				  int? RESULT = null;
			 RESULT = new int?(Axis.ATTRIBUTE);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(42, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 32: // NameTestPattern ::= QName
			  {
				  object RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int qnleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int qnright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			QName qn = (QName)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = qn;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(34, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 31: // NameTestPattern ::= STAR
			  {
				  object RESULT = null;
			 RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(34, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 30: // NodeTestPattern ::= PI
			  {
				  object RESULT = null;
			 RESULT = new int?(NodeTest.PI);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(33, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 29: // NodeTestPattern ::= COMMENT
			  {
				  object RESULT = null;
			 RESULT = new int?(NodeTest.COMMENT);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(33, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 28: // NodeTestPattern ::= TEXT
			  {
				  object RESULT = null;
			 RESULT = new int?(NodeTest.TEXT);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(33, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 27: // NodeTestPattern ::= NODE
			  {
				  object RESULT = null;
			 RESULT = new int?(NodeTest.ANODE);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(33, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 26: // NodeTestPattern ::= NameTestPattern
			  {
				  object RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object nt = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = nt;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(33, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 25: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern Predicates
			  {
				  StepPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int? axis = (int?)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pipleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pipright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			StepPattern pip = (StepPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList pp = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			   // TODO: report error if axis is attribute	
			   RESULT = (ProcessingInstructionPattern)pip.setPredicates(pp);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(32, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 24: // StepPattern ::= ChildOrAttributeAxisSpecifier ProcessingInstructionPattern
			  {
				  StepPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int? axis = (int?)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pipleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pipright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			StepPattern pip = (StepPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			   RESULT = pip; // TODO: report error if axis is attribute

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(32, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 23: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern Predicates
			  {
				  StepPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int? axis = (int?)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object nt = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList pp = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			   RESULT = parser.createStepPattern(axis.Value, nt, pp);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(32, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 22: // StepPattern ::= ChildOrAttributeAxisSpecifier NodeTestPattern
			  {
				  StepPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int axisright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int? axis = (int?)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object nt = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			   RESULT = parser.createStepPattern(axis.Value, nt, null);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(32, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 21: // StepPattern ::= ProcessingInstructionPattern Predicates
			  {
				  StepPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pipleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pipright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			StepPattern pip = (StepPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList pp = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = (ProcessingInstructionPattern)pip.setPredicates(pp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(32, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 20: // StepPattern ::= ProcessingInstructionPattern
			  {
				  StepPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pipleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pipright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			StepPattern pip = (StepPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = pip;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(32, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 19: // StepPattern ::= NodeTestPattern Predicates
			  {
				  StepPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object nt = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			ArrayList pp = (ArrayList)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			RESULT = parser.createStepPattern(Axis.CHILD, nt, pp);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(32, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 18: // StepPattern ::= NodeTestPattern
			  {
				  StepPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ntright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			object nt = (object)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;

			RESULT = parser.createStepPattern(Axis.CHILD, nt, null);

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(32, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 17: // RelativePathPattern ::= StepPattern DSLASH RelativePathPattern
			  {
				  RelativePathPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int spleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int spright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			StepPattern sp = (StepPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			RelativePathPattern rpp = (RelativePathPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new AncestorPattern(sp, rpp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(31, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 16: // RelativePathPattern ::= StepPattern SLASH RelativePathPattern
			  {
				  RelativePathPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int spleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int spright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			StepPattern sp = (StepPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			RelativePathPattern rpp = (RelativePathPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new ParentPattern(sp, rpp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(31, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 15: // RelativePathPattern ::= StepPattern
			  {
				  RelativePathPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int spleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int spright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			StepPattern sp = (StepPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = sp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(31, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 14: // ProcessingInstructionPattern ::= PIPARAM LPAREN Literal RPAREN
			  {
				  StepPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			string l = (string)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
			 RESULT = new ProcessingInstructionPattern(l);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(30, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 13: // IdKeyPattern ::= KEY LPAREN Literal COMMA Literal RPAREN
			  {
				  IdKeyPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int l1left = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int l1right = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			string l1 = (string)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int l2left = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int l2right = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			string l2 = (string)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
			 RESULT = new KeyPattern(l1, l2);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(27, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 5)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 12: // IdKeyPattern ::= ID LPAREN Literal RPAREN
			  {
				  IdKeyPattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			string l = (string)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
			 RESULT = new IdPattern(l);
				   parser.HasIdCall = true;

//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(27, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 3)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 11: // LocationPathPattern ::= RelativePathPattern
			  {
				  Pattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			RelativePathPattern rpp = (RelativePathPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = rpp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(29, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 10: // LocationPathPattern ::= DSLASH RelativePathPattern
			  {
				  Pattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			RelativePathPattern rpp = (RelativePathPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new AncestorPattern(rpp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(29, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 9: // LocationPathPattern ::= IdKeyPattern DSLASH RelativePathPattern
			  {
				  Pattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ikpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ikpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			IdKeyPattern ikp = (IdKeyPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			RelativePathPattern rpp = (RelativePathPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new AncestorPattern(ikp, rpp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(29, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 8: // LocationPathPattern ::= IdKeyPattern SLASH RelativePathPattern
			  {
				  Pattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ikpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ikpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			IdKeyPattern ikp = (IdKeyPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			RelativePathPattern rpp = (RelativePathPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new ParentPattern(ikp, rpp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(29, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 7: // LocationPathPattern ::= IdKeyPattern
			  {
				  Pattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ikpleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int ikpright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			IdKeyPattern ikp = (IdKeyPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = ikp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(29, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 6: // LocationPathPattern ::= SLASH RelativePathPattern
			  {
				  Pattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int rppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			RelativePathPattern rpp = (RelativePathPattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new AbsolutePathPattern(rpp);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(29, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 5: // LocationPathPattern ::= SLASH
			  {
				  Pattern RESULT = null;
			 RESULT = new AbsolutePathPattern(null);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(29, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 4: // Pattern ::= LocationPathPattern VBAR Pattern
			  {
				  Pattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Pattern lpp = (Pattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).value;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int pright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Pattern p = (Pattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = new AlternativePattern(lpp, p);
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(28, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 2)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 3: // Pattern ::= LocationPathPattern
			  {
				  Pattern RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lppleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int lppright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Pattern lpp = (Pattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = lpp;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(28, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 2: // TopLevel ::= EXPRESSION Expr
			  {
				  SyntaxTreeNode RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int exprleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int exprright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Expression expr = (Expression)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = expr;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(1, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 1: // TopLevel ::= PATTERN Pattern
			  {
				  SyntaxTreeNode RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int patternleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int patternright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			Pattern pattern = (Pattern)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).value;
			 RESULT = pattern;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(1, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  return CUP_XPathParser_result;

			  /*. . . . . . . . . . . . . . . . . . . .*/
			  case 0: // $START ::= TopLevel EOF
			  {
				  object RESULT = null;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int start_valleft = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			int start_valright = ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).right;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
			SyntaxTreeNode start_val = (SyntaxTreeNode)((java_cup.runtime.Symbol) CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).value;
			RESULT = start_val;
//JAVA TO C# CONVERTER TODO TASK: There is no direct .NET Stack equivalent to Java Stack methods based on internal indexing:
				  CUP_XPathParser_result = new java_cup.runtime.Symbol(0, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 1)).left, ((java_cup.runtime.Symbol)CUP_XPathParser_stack.elementAt(CUP_XPathParser_top - 0)).right, RESULT);
			  }
			  /* ACCEPT */
			  CUP_XPathParser_parser.done_parsing();
			  return CUP_XPathParser_result;

			  /* . . . . . .*/
			  default:
				throw new Exception("Invalid action number found in internal parse table");

		  }
	  }
	}


}